{"version":3,"file":"Decoder.js","sourceRoot":"","sources":["../../src/decoder/Decoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { TypeContext } from \"../types/TypeContext\";\nimport { $changes, $childType, $decoder, $onDecodeEnd } from \"../types/symbols\";\nimport { Schema } from \"../Schema\";\n\nimport { decode } from \"../encoding/decode\";\nimport { OPERATION, SWITCH_TO_STRUCTURE, TYPE_ID } from '../encoding/spec';\nimport type { Ref } from \"../encoder/ChangeTree\";\nimport type { Iterator } from \"../encoding/decode\";\nimport { ReferenceTracker } from \"./ReferenceTracker\";\nimport { DEFINITION_MISMATCH, type DataChange, type DecodeOperation } from \"./DecodeOperation\";\nimport { Collection } from \"../types/HelperTypes\";\n\nexport class Decoder<T extends Schema = any> {\n    context: TypeContext;\n\n    state: T;\n    root: ReferenceTracker;\n\n    currentRefId: number = 0;\n\n    triggerChanges?: (allChanges: DataChange[]) => void;\n\n    constructor(root: T, context?: TypeContext) {\n        this.setState(root);\n\n        this.context = context || new TypeContext(root.constructor as typeof Schema);\n\n        // console.log(\">>>>>>>>>>>>>>>> Decoder types\");\n        // this.context.schemas.forEach((id, schema) => {\n        //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\n        // });\n    }\n\n    protected setState(root: T) {\n        this.state = root;\n        this.root = new ReferenceTracker();\n        this.root.addRef(0, root);\n    }\n\n    decode(\n        bytes: Buffer,\n        it: Iterator = { offset: 0 },\n        ref: Ref = this.state,\n    ) {\n        const allChanges: DataChange[] = [];\n\n        const $root = this.root;\n        const totalBytes = bytes.byteLength;\n\n        let decoder: DecodeOperation = ref['constructor'][$decoder];\n\n        this.currentRefId = 0;\n\n        while (it.offset < totalBytes) {\n            //\n            // Peek ahead, check if it's a switch to a different structure\n            //\n            if (bytes[it.offset] == SWITCH_TO_STRUCTURE) {\n                it.offset++;\n\n                this.currentRefId = decode.number(bytes, it);\n                const nextRef = $root.refs.get(this.currentRefId) as Schema;\n\n                //\n                // Trying to access a reference that haven't been decoded yet.\n                //\n                if (!nextRef) { throw new Error(`\"refId\" not found: ${this.currentRefId}`); }\n                ref[$onDecodeEnd]?.()\n                ref = nextRef;\n\n                decoder = ref.constructor[$decoder];\n\n                continue;\n            }\n\n            const result = decoder(this, bytes, it, ref, allChanges);\n\n            if (result === DEFINITION_MISMATCH) {\n                console.warn(\"@colyseus/schema: definition mismatch\");\n\n                //\n                // keep skipping next bytes until reaches a known structure\n                // by local decoder.\n                //\n                const nextIterator: Iterator = { offset: it.offset };\n                while (it.offset < totalBytes) {\n                    if (bytes[it.offset] === SWITCH_TO_STRUCTURE) {\n                        nextIterator.offset = it.offset + 1;\n                        if ($root.refs.has(decode.number(bytes, nextIterator))) {\n                            break;\n                        }\n                    }\n\n                    it.offset++;\n                }\n                continue;\n            }\n        }\n\n        // FIXME: DRY with SWITCH_TO_STRUCTURE block.\n        ref[$onDecodeEnd]?.()\n\n        // trigger changes\n        this.triggerChanges?.(allChanges);\n\n        // drop references of unused schemas\n        $root.garbageCollectDeletedRefs();\n\n        return allChanges;\n    }\n\n    getInstanceType(bytes: Buffer, it: Iterator, defaultType: typeof Schema): typeof Schema {\n        let type: typeof Schema;\n\n        if (bytes[it.offset] === TYPE_ID) {\n            it.offset++;\n            const type_id = decode.number(bytes, it);\n            type = this.context.get(type_id);\n        }\n\n        return type || defaultType;\n    }\n\n    createInstanceOfType (type: typeof Schema): Schema {\n        // let instance: Schema = new (type as any)();\n\n        // // assign root on $changes\n        // instance[$changes].root = this.root[$changes].root;\n\n        // return instance;\n        return new (type as any)();\n    }\n\n    removeChildRefs(ref: Collection, allChanges: DataChange[]) {\n        const needRemoveRef = typeof (ref[$childType]) !== \"string\";\n        const refId = this.root.refIds.get(ref as Ref);\n\n        ref.forEach((value: any, key: any) => {\n            allChanges.push({\n                ref: ref as Ref,\n                refId,\n                op: OPERATION.DELETE,\n                field: key,\n                value: undefined,\n                previousValue: value\n            });\n\n            if (needRemoveRef) {\n                this.root.removeRef(this.root.refIds.get(value));\n            }\n        });\n    }\n\n}\n\n"]}