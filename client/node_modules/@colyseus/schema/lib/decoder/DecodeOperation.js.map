{"version":3,"file":"DecodeOperation.js","sourceRoot":"","sources":["../../src/decoder/DecodeOperation.ts"],"names":[],"mappings":"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","sourcesContent":["import { OPERATION } from \"../encoding/spec\";\nimport { Metadata } from \"../Metadata\";\nimport { Schema } from \"../Schema\";\nimport type { Ref } from \"../encoder/ChangeTree\";\nimport type { Decoder } from \"./Decoder\";\nimport { Iterator, decode } from \"../encoding/decode\";\nimport { $childType, $deleteByIndex, $getByIndex } from \"../types/symbols\";\n\nimport type { MapSchema } from \"../types/custom/MapSchema\";\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\nimport type { CollectionSchema } from \"../types/custom/CollectionSchema\";\n\nimport { getType } from \"../types/registry\";\nimport { Collection } from \"../types/HelperTypes\";\n\nexport interface DataChange<T = any, F = string> {\n    ref: Ref,\n    refId: number,\n    op: OPERATION,\n    field: F;\n    dynamicIndex?: number | string;\n    value: T;\n    previousValue: T;\n}\n\nexport const DEFINITION_MISMATCH = -1;\n\nexport type DecodeOperation<T extends Schema = any> = (\n    decoder: Decoder<T>,\n    bytes: Buffer,\n    it: Iterator,\n    ref: Ref,\n    allChanges: DataChange[],\n) => number | void;\n\nexport function decodeValue(\n    decoder: Decoder,\n    operation: OPERATION,\n    ref: Ref,\n    index: number,\n    type: any,\n    bytes: Buffer,\n    it: Iterator,\n    allChanges: DataChange[],\n) {\n    const $root = decoder.root;\n    const previousValue = ref[$getByIndex](index);\n\n    let value: any;\n\n    if ((operation & OPERATION.DELETE) === OPERATION.DELETE)\n    {\n        // Flag `refId` for garbage collection.\n        const previousRefId = $root.refIds.get(previousValue);\n        if (previousRefId !== undefined) { $root.removeRef(previousRefId); }\n\n        //\n        // Delete operations\n        //\n        if (operation !== OPERATION.DELETE_AND_ADD) {\n            ref[$deleteByIndex](index);\n        }\n\n        value = undefined;\n    }\n\n    if (operation === OPERATION.DELETE) {\n        //\n        // Don't do anything\n        //\n\n    } else if (Schema.is(type)) {\n        const refId = decode.number(bytes, it);\n        value = $root.refs.get(refId);\n\n        if ((operation & OPERATION.ADD) === OPERATION.ADD) {\n            const childType = decoder.getInstanceType(bytes, it, type);\n            if (!value) {\n                value = decoder.createInstanceOfType(childType);\n            }\n\n            $root.addRef(\n                refId,\n                value,\n                (\n                    value !== previousValue || // increment ref count if value has changed\n                    (operation === OPERATION.DELETE_AND_ADD && value === previousValue) // increment ref count if the same instance is being added again\n                )\n            );\n        }\n\n    } else if (typeof(type) === \"string\") {\n        //\n        // primitive value (number, string, boolean, etc)\n        //\n        value = decode[type as string](bytes, it);\n\n    } else {\n        const typeDef = getType(Object.keys(type)[0]);\n        const refId = decode.number(bytes, it);\n\n        const valueRef: Ref = ($root.refs.has(refId))\n            ? previousValue || $root.refs.get(refId)\n            : new typeDef.constructor();\n\n        value = valueRef.clone(true);\n        value[$childType] = Object.values(type)[0]; // cache childType for ArraySchema and MapSchema\n\n        if (previousValue) {\n            let previousRefId = $root.refIds.get(previousValue);\n\n            if (previousRefId !== undefined && refId !== previousRefId) {\n                //\n                // enqueue onRemove if structure has been replaced.\n                //\n                const entries: IterableIterator<[any, any]> = previousValue.entries();\n                let iter: IteratorResult<[any, any]>;\n                while ((iter = entries.next()) && !iter.done) {\n                    const [key, value] = iter.value;\n\n                    // if value is a schema, remove its reference\n                    if (typeof(value) === \"object\") {\n                        previousRefId = $root.refIds.get(value);\n                        $root.removeRef(previousRefId);\n                    }\n\n                    allChanges.push({\n                        ref: previousValue,\n                        refId: previousRefId,\n                        op: OPERATION.DELETE,\n                        field: key,\n                        value: undefined,\n                        previousValue: value,\n                    });\n                }\n\n            }\n        }\n\n        $root.addRef(refId, value, (\n            valueRef !== previousValue ||\n            (operation === OPERATION.DELETE_AND_ADD && valueRef === previousValue)\n        ));\n    }\n\n    return { value, previousValue };\n}\n\nexport const decodeSchemaOperation: DecodeOperation = function (\n    decoder: Decoder<any>,\n    bytes: Buffer,\n    it: Iterator,\n    ref: Ref,\n    allChanges: DataChange[],\n) {\n    const first_byte = bytes[it.offset++];\n    const metadata: Metadata = ref.constructor[Symbol.metadata];\n\n    // \"compressed\" index + operation\n    const operation = (first_byte >> 6) << 6\n    const index = first_byte % (operation || 255);\n\n    // skip early if field is not defined\n    const field = metadata[index];\n    if (field === undefined) {\n        console.warn(\"@colyseus/schema: field not defined at\", { index, ref: ref.constructor.name, metadata });\n        return DEFINITION_MISMATCH;\n    }\n\n    const { value, previousValue } = decodeValue(\n        decoder,\n        operation,\n        ref,\n        index,\n        field.type,\n        bytes,\n        it,\n        allChanges,\n    );\n\n    if (value !== null && value !== undefined) {\n        ref[field.name] = value;\n    }\n\n    // add change\n    if (previousValue !== value) {\n        allChanges.push({\n            ref,\n            refId: decoder.currentRefId,\n            op: operation,\n            field: field.name,\n            value,\n            previousValue,\n        });\n    }\n}\n\nexport const decodeKeyValueOperation: DecodeOperation = function (\n    decoder: Decoder<any>,\n    bytes: Buffer,\n    it: Iterator,\n    ref: Ref,\n    allChanges: DataChange[]\n) {\n    // \"uncompressed\" index + operation (array/map items)\n    const operation = bytes[it.offset++];\n\n    if (operation === OPERATION.CLEAR) {\n        //\n        // When decoding:\n        // - enqueue items for DELETE callback.\n        // - flag child items for garbage collection.\n        //\n        decoder.removeChildRefs(ref as unknown as Collection, allChanges);\n\n        (ref as any).clear();\n        return;\n    }\n\n    const index = decode.number(bytes, it);\n    const type = ref[$childType];\n\n    let dynamicIndex: number | string;\n\n    if ((operation & OPERATION.ADD) === OPERATION.ADD) { // ADD or DELETE_AND_ADD\n        if (typeof(ref['set']) === \"function\") {\n            dynamicIndex = decode.string(bytes, it); // MapSchema\n            ref['setIndex'](index, dynamicIndex);\n        } else {\n            dynamicIndex = index; // ArraySchema\n        }\n    } else {\n        // get dynamic index from \"ref\"\n        dynamicIndex = ref['getIndex'](index);\n    }\n\n\n    const { value, previousValue } = decodeValue(\n        decoder,\n        operation,\n        ref,\n        index,\n        type,\n        bytes,\n        it,\n        allChanges,\n    );\n\n    if (value !== null && value !== undefined) {\n        if (typeof(ref['set']) === \"function\") {\n            // MapSchema\n            (ref as MapSchema)['$items'].set(dynamicIndex as string, value);\n\n        } else if (typeof(ref['$setAt']) === \"function\") {\n            // ArraySchema\n            (ref as ArraySchema)['$setAt'](index, value, operation);\n\n        } else if (typeof(ref['add']) === \"function\") {\n            // CollectionSchema && SetSchema\n            const index = (ref as CollectionSchema).add(value);\n\n            if (typeof(index) === \"number\") {\n                ref['setIndex'](index, index);\n            }\n        }\n    }\n\n    // add change\n    if (previousValue !== value) {\n        allChanges.push({\n            ref,\n            refId: decoder.currentRefId,\n            op: operation,\n            field: \"\", // FIXME: remove this\n            dynamicIndex,\n            value,\n            previousValue,\n        });\n    }\n}\n\nexport const decodeArray: DecodeOperation = function (\n    decoder: Decoder<any>,\n    bytes: Buffer,\n    it: Iterator,\n    ref: ArraySchema,\n    allChanges: DataChange[]\n) {\n    // \"uncompressed\" index + operation (array/map items)\n    let operation = bytes[it.offset++];\n    let index: number;\n\n    if (operation === OPERATION.CLEAR) {\n        //\n        // When decoding:\n        // - enqueue items for DELETE callback.\n        // - flag child items for garbage collection.\n        //\n        decoder.removeChildRefs(ref as unknown as Collection, allChanges);\n        (ref as ArraySchema).clear();\n        return;\n\n    } else if (operation === OPERATION.REVERSE) {\n        (ref as ArraySchema).reverse();\n        return;\n\n    } else if (operation === OPERATION.DELETE_BY_REFID) {\n        // TODO: refactor here, try to follow same flow as below\n        const refId = decode.number(bytes, it);\n        const previousValue = decoder.root.refs.get(refId);\n        index = ref.findIndex((value) => value === previousValue);\n        ref[$deleteByIndex](index);\n        allChanges.push({\n            ref,\n            refId: decoder.currentRefId,\n            op: OPERATION.DELETE,\n            field: \"\", // FIXME: remove this\n            dynamicIndex: index,\n            value: undefined,\n            previousValue,\n        });\n\n        return;\n\n    } else if (operation === OPERATION.ADD_BY_REFID) {\n        const refId = decode.number(bytes, it);\n        const itemByRefId = decoder.root.refs.get(refId);\n\n        // if item already exists, use existing index\n        if (itemByRefId) {\n            index = ref.findIndex((value) => value === itemByRefId);\n        }\n\n        // fallback to use last index\n        if (index === -1 || index === undefined) {\n            index = ref.length;\n        }\n\n    } else {\n        index = decode.number(bytes, it);\n    }\n\n    const type = ref[$childType];\n\n    let dynamicIndex: number | string = index;\n\n    const { value, previousValue } = decodeValue(\n        decoder,\n        operation,\n        ref,\n        index,\n        type,\n        bytes,\n        it,\n        allChanges,\n    );\n\n    if (\n        value !== null && value !== undefined &&\n        value !== previousValue // avoid setting same value twice (if index === 0 it will result in a \"unshift\" for ArraySchema)\n    ) {\n        // ArraySchema\n        (ref as ArraySchema)['$setAt'](index, value, operation);\n    }\n\n    // add change\n    if (previousValue !== value) {\n        allChanges.push({\n            ref,\n            refId: decoder.currentRefId,\n            op: operation,\n            field: \"\", // FIXME: remove this\n            dynamicIndex,\n            value,\n            previousValue,\n        });\n    }\n}"]}