{"version":3,"file":"TypeContext.js","sourceRoot":"","sources":["../../src/types/TypeContext.ts"],"names":[],"mappings":"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","sourcesContent":["import { Metadata } from \"../Metadata\";\nimport { Schema } from \"../Schema\";\nimport { $viewFieldIndexes } from \"./symbols\";\n\nexport class TypeContext {\n    types: { [id: number]: typeof Schema; } = {};\n    schemas = new Map<typeof Schema, number>();\n\n    hasFilters: boolean = false;\n    parentFiltered: {[typeIdAndParentIndex: string]: boolean} = {};\n\n    /**\n     * For inheritance support\n     * Keeps track of which classes extends which. (parent -> children)\n     */\n    static inheritedTypes = new Map<typeof Schema, Set<typeof Schema>>();\n    static cachedContexts = new Map<typeof Schema, TypeContext>();\n\n    static register(target: typeof Schema) {\n        const parent = Object.getPrototypeOf(target);\n        if (parent !== Schema) {\n            let inherits = TypeContext.inheritedTypes.get(parent);\n            if (!inherits) {\n                inherits = new Set<typeof Schema>();\n                TypeContext.inheritedTypes.set(parent, inherits);\n            }\n            inherits.add(target);\n        }\n    }\n\n    static cache (rootClass: typeof Schema) {\n        let context = TypeContext.cachedContexts.get(rootClass);\n        if (!context) {\n            context = new TypeContext(rootClass);\n            TypeContext.cachedContexts.set(rootClass, context);\n        }\n        return context;\n    }\n\n    constructor(rootClass?: typeof Schema) {\n        if (rootClass) {\n            this.discoverTypes(rootClass);\n        }\n    }\n\n    has(schema: typeof Schema) {\n        return this.schemas.has(schema);\n    }\n\n    get(typeid: number) {\n        return this.types[typeid];\n    }\n\n    add(schema: typeof Schema, typeid = this.schemas.size) {\n        // skip if already registered\n        if (this.schemas.has(schema)) {\n            return false;\n        }\n\n        this.types[typeid] = schema;\n\n        //\n        // Workaround to allow using an empty Schema (with no `@type()` fields)\n        //\n        if (schema[Symbol.metadata] === undefined) {\n            Metadata.initialize(schema);\n        }\n\n        this.schemas.set(schema, typeid);\n        return true;\n    }\n\n    getTypeId(klass: typeof Schema) {\n        return this.schemas.get(klass);\n    }\n\n    private discoverTypes(klass: typeof Schema, parentType?: typeof Schema, parentIndex?: number, parentHasViewTag?: boolean) {\n        if (parentHasViewTag) {\n            this.registerFilteredByParent(klass, parentType, parentIndex);\n        }\n\n        // skip if already registered\n        if (!this.add(klass)) { return; }\n\n        // add classes inherited from this base class\n        TypeContext.inheritedTypes.get(klass)?.forEach((child) => {\n            this.discoverTypes(child, parentType, parentIndex, parentHasViewTag);\n        });\n\n        // add parent classes\n        let parent: any = klass;\n        while (\n            (parent = Object.getPrototypeOf(parent)) &&\n            parent !== Schema && // stop at root (Schema)\n            parent !== Function.prototype // stop at root (non-Schema)\n        ) {\n            this.discoverTypes(parent);\n        }\n\n        const metadata: Metadata = (klass[Symbol.metadata] ??= {});\n\n        // if any schema/field has filters, mark \"context\" as having filters.\n        if (metadata[$viewFieldIndexes]) {\n            this.hasFilters = true;\n        }\n\n        for (const fieldIndex in metadata) {\n            const index = fieldIndex as any as number;\n\n            const fieldType = metadata[index].type;\n            const fieldHasViewTag = (metadata[index].tag !== undefined);\n\n            if (typeof (fieldType) === \"string\") {\n                continue;\n            }\n\n            if (Array.isArray(fieldType)) {\n                const type = fieldType[0];\n\n                // skip primitive types\n                if (type === \"string\") {\n                    continue;\n                }\n\n                this.discoverTypes(type as typeof Schema, klass, index, parentHasViewTag || fieldHasViewTag);\n\n            } else if (typeof (fieldType) === \"function\") {\n                this.discoverTypes(fieldType as typeof Schema, klass, index, parentHasViewTag || fieldHasViewTag);\n\n            } else {\n                const type = Object.values(fieldType)[0];\n\n                // skip primitive types\n                if (typeof (type) === \"string\") {\n                    continue;\n                }\n\n                this.discoverTypes(type as typeof Schema, klass, index, parentHasViewTag || fieldHasViewTag);\n            }\n        }\n    }\n\n    /**\n     * Keep track of which classes have filters applied.\n     * Format: `${typeid}-${parentTypeid}-${parentIndex}`\n     */\n    private registerFilteredByParent(schema: typeof Schema, parentType?: typeof Schema, parentIndex?: number) {\n        const typeid = this.schemas.get(schema) ?? this.schemas.size;\n\n        let key = `${typeid}`;\n        if (parentType) { key += `-${this.schemas.get(parentType)}`; }\n\n        key += `-${parentIndex}`;\n        this.parentFiltered[key] = true;\n    }\n\n    debug() {\n        let parentFiltered = \"\";\n\n        for (const key in this.parentFiltered) {\n            const keys: number[] = key.split(\"-\").map(Number);\n            const fieldIndex = keys.pop();\n\n            parentFiltered += `\\n\\t\\t`;\n            parentFiltered += `${key}: ${keys.reverse().map((id, i) => {\n                const klass = this.types[id];\n                const metadata: Metadata = klass[Symbol.metadata];\n                let txt = klass.name;\n                if (i === 0) { txt += `[${metadata[fieldIndex].name}]`; }\n                return `${txt}`;\n            }).join(\" -> \")}`;\n        }\n\n        return `TypeContext ->\\n` +\n            `\\tSchema types: ${this.schemas.size}\\n` +\n            `\\thasFilters: ${this.hasFilters}\\n` +\n            `\\tparentFiltered:${parentFiltered}`;\n    }\n\n}\n"]}