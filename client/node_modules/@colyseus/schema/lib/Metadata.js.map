{"version":3,"file":"Metadata.js","sourceRoot":"","sources":["../src/Metadata.ts"],"names":[],"mappings":";;;AAwBA,8CAMC;AA9BD,+CAAsE;AACtE,qCAAkC;AAClC,+CAA2C;AAC3C,6CAAwJ;AACxJ,qDAAkD;AAoBlD,SAAgB,iBAAiB,CAAC,IAAoB;IAClD,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACxB,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE;QACpB,CAAC,CAAC,CAAC,OAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,WAAW,CAAC;YACpC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;YACd,CAAC,CAAC,IAAI,CAAC;AACnB,CAAC;AAED,oDAAoD;AACpD,SAAS,QAAQ,CAAC,KAAU;IACxB,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAChC,MAAM,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACtD,OAAO,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9G,CAAC;AAEY,QAAA,QAAQ,GAAG;IAEpB,QAAQ,CAAC,QAAa,EAAE,KAAa,EAAE,IAAY,EAAE,IAAoB,EAAE,UAA+B;QACtG,IAAI,KAAK,GAAG,EAAE,EAAE,CAAC;YACb,MAAM,IAAI,KAAK,CAAC,uBAAuB,IAAI,qDAAqD,CAAC,CAAC;QACtG,CAAC;QAED,QAAQ,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,MAAM,CAC3B,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,mEAAmE;QAC1F;YACI,IAAI,EAAE,iBAAiB,CAAC,IAAI,CAAC;YAC7B,KAAK;YACL,IAAI;SACP,CACJ,CAAC;QAEF,2BAA2B;QAC3B,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,sBAAY,EAAE;YAC1C,KAAK,EAAE,QAAQ,CAAC,sBAAY,CAAC,IAAI,EAAE;YACnC,UAAU,EAAE,KAAK;YACjB,YAAY,EAAE,IAAI;SACrB,CAAC,CAAC;QAEH,IAAI,UAAU,EAAE,CAAC;YACb,cAAc;YACd,QAAQ,CAAC,sBAAY,CAAC,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC;YAC1C,QAAQ,CAAC,sBAAY,CAAC,CAAC,IAAI,IAAI,EAAE,CAAC,GAAG;gBACjC,KAAK,EAAE,SAAS;gBAChB,QAAQ,EAAE,IAAI;gBACd,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;aACrB,CAAC;QACN,CAAC;aAAM,CAAC;YACJ,cAAc;YACd,QAAQ,CAAC,sBAAY,CAAC,CAAC,IAAI,CAAC,GAAG;gBAC3B,KAAK,EAAE,SAAS;gBAChB,QAAQ,EAAE,IAAI;gBACd,UAAU,EAAE,IAAI;gBAChB,YAAY,EAAE,IAAI;aACrB,CAAC;QACN,CAAC;QAED,6BAA6B;QAC7B,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,oBAAU,EAAE;YACxC,KAAK,EAAE,KAAK;YACZ,UAAU,EAAE,KAAK;YACjB,YAAY,EAAE,IAAI;SACrB,CAAC,CAAC;QAEH,2CAA2C;QAC3C,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,IAAI,EAAE;YAClC,KAAK,EAAE,KAAK;YACZ,UAAU,EAAE,KAAK;YACjB,YAAY,EAAE,IAAI;SACrB,CAAC,CAAC;QAEH,uCAAuC;QACvC,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,QAAQ,EAAE,CAAC;YAC7C,IAAI,QAAQ,CAAC,8BAAoB,CAAC,KAAK,SAAS,EAAE,CAAC;gBAC/C,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,8BAAoB,EAAE;oBAClD,KAAK,EAAE,EAAE;oBACT,UAAU,EAAE,KAAK;oBACjB,YAAY,EAAE,IAAI;iBACrB,CAAC,CAAC;YACP,CAAC;YACD,QAAQ,CAAC,8BAAoB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC/C,CAAC;IACL,CAAC;IAED,MAAM,CAAC,QAAkB,EAAE,SAAiB,EAAE,GAAW;QACrD,MAAM,KAAK,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;QAClC,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;QAE9B,yBAAyB;QACzB,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;QAEhB,IAAI,CAAC,QAAQ,CAAC,2BAAiB,CAAC,EAAE,CAAC;YAC/B,wCAAwC;YACxC,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,2BAAiB,EAAE;gBAC/C,KAAK,EAAE,EAAE;gBACT,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;aACrB,CAAC,CAAC;YAEH,kCAAkC;YAClC,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,gCAAsB,EAAE;gBACpD,KAAK,EAAE,EAAE;gBACT,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;aACrB,CAAC,CAAC;QACP,CAAC;QAED,QAAQ,CAAC,2BAAiB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAExC,IAAI,CAAC,QAAQ,CAAC,gCAAsB,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC;YACzC,QAAQ,CAAC,gCAAsB,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;QAC/C,CAAC;QAED,QAAQ,CAAC,gCAAsB,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACtD,CAAC;IAED,SAAS,CAA4D,MAAS,EAAE,MAA6D;QACzI,0BAA0B;QAC1B,MAAM,WAAW,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW,CAAC;QACjD,yBAAW,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QAElC,MAAM,WAAW,GAAG,MAAM,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;QACvD,MAAM,cAAc,GAAG,WAAW,IAAI,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QACnE,MAAM,QAAQ,GAAG,gBAAQ,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAElD,mDAAmD;QACnD,IAAI,CAAC,WAAW,CAAC,gBAAM,CAAC,EAAE,CAAC;YAAC,WAAW,CAAC,gBAAM,CAAC,GAAG,eAAM,CAAC,gBAAM,CAAC,CAAC;QAAC,CAAC;QACnE,IAAI,CAAC,WAAW,CAAC,kBAAQ,CAAC,EAAE,CAAC;YAAC,WAAW,CAAC,kBAAQ,CAAC,GAAG,eAAM,CAAC,kBAAQ,CAAC,CAAC;QAAC,CAAC;QACzE,IAAI,CAAC,WAAW,CAAC,kBAAQ,CAAC,EAAE,CAAC;YAAC,WAAW,CAAC,kBAAQ,CAAC,GAAG,eAAM,CAAC,kBAAQ,CAAC,CAAC;QAAC,CAAC;QACzE,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC;YAAC,WAAW,CAAC,SAAS,CAAC,MAAM,GAAG,eAAM,CAAC,SAAS,CAAC,MAAM,CAAC;QAAC,CAAC;QAE9F,EAAE;QACF,uDAAuD;QACvD,EAAE;QACF,IAAI,UAAU,GAAG,QAAQ,CAAC,oBAAU,CAAC,CAAC,+CAA+C;eAC9E,CAAC,cAAc,IAAI,cAAc,CAAC,oBAAU,CAAC,CAAC,CAAC,sCAAsC;eACrF,CAAC,CAAC,CAAC,CAAC,oBAAoB;QAE/B,UAAU,EAAE,CAAC;QAEb,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;YACzB,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;YAE3B,yDAAyD;YACzD,MAAM,gBAAgB,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBAC1C,CAAC,CAAC,IAAA,kBAAO,EAAC,OAAO,CAAC;gBAClB,CAAC,CAAC,CAAC,OAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ,CAAC,IAAI,IAAA,kBAAO,EAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAEnF,MAAM,SAAS,GAAG,CAAC,gBAAgB,CAAC;gBAChC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACxB,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;YAE9B,gBAAQ,CAAC,QAAQ,CACb,QAAQ,EACR,UAAU,EACV,KAAK,EACL,IAAI,EACJ,IAAA,mCAAqB,EAAC,IAAI,KAAK,EAAE,EAAE,UAAU,EAAE,SAAS,EAAE,gBAAgB,CAAC,CAC9E,CAAC;YAEF,UAAU,EAAE,CAAC;QACjB,CAAC;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAED,YAAY,CAAC,QAAa,EAAE,KAAa;QACrC,OAAO,QAAQ,CAAC,KAAK,CAAC,CAAC,UAAU,KAAK,IAAI,CAAC;IAC/C,CAAC;IAED,IAAI,CAAC,KAAU;QACX,EAAE;QACF,gEAAgE;QAChE,gCAAgC;QAChC,EAAE;QACF,MAAM,QAAQ,GAAG,EAAE,CAAC;QACpB,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC;QAClC,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,oBAAU,EAAE;YACxC,KAAK,EAAE,CAAC;YACR,UAAU,EAAE,KAAK;YACjB,YAAY,EAAE,IAAI;SACrB,CAAC,CAAC;IACP,CAAC;IAED,UAAU,CAAC,WAAgB;QACvB,MAAM,WAAW,GAAG,MAAM,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;QACvD,MAAM,cAAc,GAAa,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAE9D,IAAI,QAAQ,GAAa,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAE7E,8DAA8D;QAC9D,IAAI,WAAW,KAAK,eAAM,IAAI,QAAQ,KAAK,cAAc,EAAE,CAAC;YACxD,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAE/B,IAAI,cAAc,EAAE,CAAC;gBACjB,EAAE;gBACF,oCAAoC;gBACpC,EAAE;gBACF,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;gBAEhD,aAAa;gBACb,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,oBAAU,EAAE;oBACxC,KAAK,EAAE,cAAc,CAAC,oBAAU,CAAC;oBACjC,UAAU,EAAE,KAAK;oBACjB,YAAY,EAAE,IAAI;oBAClB,QAAQ,EAAE,IAAI;iBACjB,CAAC,CAAC;gBAEH,6CAA6C;gBAC7C,IAAI,cAAc,CAAC,2BAAiB,CAAC,KAAK,SAAS,EAAE,CAAC;oBAClD,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,2BAAiB,EAAE;wBAC/C,KAAK,EAAE,CAAC,GAAG,cAAc,CAAC,2BAAiB,CAAC,CAAC;wBAC7C,UAAU,EAAE,KAAK;wBACjB,YAAY,EAAE,IAAI;wBAClB,QAAQ,EAAE,IAAI;qBACjB,CAAC,CAAC;oBACH,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,gCAAsB,EAAE;wBACpD,KAAK,EAAE,EAAE,GAAG,cAAc,CAAC,gCAAsB,CAAC,EAAE;wBACpD,UAAU,EAAE,KAAK;wBACjB,YAAY,EAAE,IAAI;wBAClB,QAAQ,EAAE,IAAI;qBACjB,CAAC,CAAC;gBACP,CAAC;gBAED,uBAAuB;gBACvB,IAAI,cAAc,CAAC,8BAAoB,CAAC,KAAK,SAAS,EAAE,CAAC;oBACrD,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,8BAAoB,EAAE;wBAClD,KAAK,EAAE,CAAC,GAAG,cAAc,CAAC,8BAAoB,CAAC,CAAC;wBAChD,UAAU,EAAE,KAAK;wBACjB,YAAY,EAAE,IAAI;wBAClB,QAAQ,EAAE,IAAI;qBACjB,CAAC,CAAC;gBACP,CAAC;gBAED,eAAe;gBACf,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,sBAAY,EAAE;oBAC1C,KAAK,EAAE,EAAE,GAAG,cAAc,CAAC,sBAAY,CAAC,EAAE;oBAC1C,UAAU,EAAE,KAAK;oBACjB,YAAY,EAAE,IAAI;oBAClB,QAAQ,EAAE,IAAI;iBACjB,CAAC,CAAC;YACP,CAAC;QACL,CAAC;QAED,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC;QAExC,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED,eAAe,CAAC,KAAU;QACtB,OAAO,CACH,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC;YAClC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,oBAAU,CAAY,CAClG,CAAC;IACN,CAAC;IAED,SAAS,CAAC,KAAU;QAChB,MAAM,QAAQ,GAAa,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAClD,MAAM,MAAM,GAAG,EAAE,CAAC;QAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,QAAQ,CAAC,oBAAU,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC7C,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAChD,CAAC;QACD,OAAO,MAAM,CAAC;IAClB,CAAC;IAED,iBAAiB,CAAC,QAAkB,EAAE,KAAa;QAC/C,OAAO,QAAQ,EAAE,CAAC,2BAAiB,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC;IAC1D,CAAC;CACJ,CAAA","sourcesContent":["import { DefinitionType, getPropertyDescriptor } from \"./annotations\";\nimport { Schema } from \"./Schema\";\nimport { getType } from \"./types/registry\";\nimport { $decoder, $descriptors, $encoder, $fieldIndexesByViewTag, $numFields, $refTypeFieldIndexes, $track, $viewFieldIndexes } from \"./types/symbols\";\nimport { TypeContext } from \"./types/TypeContext\";\n\nexport type MetadataField = {\n    type: DefinitionType,\n    name: string,\n    index: number,\n    tag?: number,\n    unreliable?: boolean,\n    deprecated?: boolean,\n};\n\nexport type Metadata =\n    { [$numFields]: number; } & // number of fields\n    { [$viewFieldIndexes]: number[]; } & // all field indexes with \"view\" tag\n    { [$fieldIndexesByViewTag]: {[tag: number]: number[]}; } & // field indexes by \"view\" tag\n    { [$refTypeFieldIndexes]: number[]; } & // all field indexes containing Ref types (Schema, ArraySchema, MapSchema, etc)\n    { [field: number]: MetadataField; } & // index => field name\n    { [field: string]: number; } & // field name => field metadata\n    { [$descriptors]: { [field: string]: PropertyDescriptor } }  // property descriptors\n\nexport function getNormalizedType(type: DefinitionType): DefinitionType  {\n    return (Array.isArray(type))\n        ? { array: type[0] }\n        : (typeof(type['type']) !== \"undefined\")\n            ? type['type']\n            : type;\n}\n\n// TODO: see test: \"should support TypeScript enums\"\nfunction isTSEnum(_enum: any) {\n    const keys = Object.keys(_enum);\n    const numericFields = keys.filter(k => /\\d+/.test(k));\n    return (numericFields.length === (keys.length / 2) && _enum[_enum[numericFields[0]]] == numericFields[0]);\n}\n\nexport const Metadata = {\n\n    addField(metadata: any, index: number, name: string, type: DefinitionType, descriptor?: PropertyDescriptor) {\n        if (index > 64) {\n            throw new Error(`Can't define field '${name}'.\\nSchema instances may only have up to 64 fields.`);\n        }\n\n        metadata[index] = Object.assign(\n            metadata[index] || {}, // avoid overwriting previous field metadata (@owned / @deprecated)\n            {\n                type: getNormalizedType(type),\n                index,\n                name,\n            }\n        );\n\n        // create \"descriptors\" map\n        Object.defineProperty(metadata, $descriptors, {\n            value: metadata[$descriptors] || {},\n            enumerable: false,\n            configurable: true,\n        });\n\n        if (descriptor) {\n            // for encoder\n            metadata[$descriptors][name] = descriptor;\n            metadata[$descriptors][`_${name}`] = {\n                value: undefined,\n                writable: true,\n                enumerable: false,\n                configurable: true,\n            };\n        } else {\n            // for decoder\n            metadata[$descriptors][name] = {\n                value: undefined,\n                writable: true,\n                enumerable: true,\n                configurable: true,\n            };\n        }\n\n        // map -1 as last field index\n        Object.defineProperty(metadata, $numFields, {\n            value: index,\n            enumerable: false,\n            configurable: true\n        });\n\n        // map field name => index (non enumerable)\n        Object.defineProperty(metadata, name, {\n            value: index,\n            enumerable: false,\n            configurable: true,\n        });\n\n        // if child Ref/complex type, add to -4\n        if (typeof (metadata[index].type) !== \"string\") {\n            if (metadata[$refTypeFieldIndexes] === undefined) {\n                Object.defineProperty(metadata, $refTypeFieldIndexes, {\n                    value: [],\n                    enumerable: false,\n                    configurable: true,\n                });\n            }\n            metadata[$refTypeFieldIndexes].push(index);\n        }\n    },\n\n    setTag(metadata: Metadata, fieldName: string, tag: number) {\n        const index = metadata[fieldName];\n        const field = metadata[index];\n\n        // add 'tag' to the field\n        field.tag = tag;\n\n        if (!metadata[$viewFieldIndexes]) {\n            // -2: all field indexes with \"view\" tag\n            Object.defineProperty(metadata, $viewFieldIndexes, {\n                value: [],\n                enumerable: false,\n                configurable: true\n            });\n\n            // -3: field indexes by \"view\" tag\n            Object.defineProperty(metadata, $fieldIndexesByViewTag, {\n                value: {},\n                enumerable: false,\n                configurable: true\n            });\n        }\n\n        metadata[$viewFieldIndexes].push(index);\n\n        if (!metadata[$fieldIndexesByViewTag][tag]) {\n            metadata[$fieldIndexesByViewTag][tag] = [];\n        }\n\n        metadata[$fieldIndexesByViewTag][tag].push(index);\n    },\n\n    setFields<T extends { new (...args: any[]): InstanceType<T> } = any>(target: T, fields: { [field in keyof InstanceType<T>]?: DefinitionType }) {\n        // for inheritance support\n        const constructor = target.prototype.constructor;\n        TypeContext.register(constructor);\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata = parentClass && parentClass[Symbol.metadata];\n        const metadata = Metadata.initialize(constructor);\n\n        // Use Schema's methods if not defined in the class\n        if (!constructor[$track]) { constructor[$track] = Schema[$track]; }\n        if (!constructor[$encoder]) { constructor[$encoder] = Schema[$encoder]; }\n        if (!constructor[$decoder]) { constructor[$decoder] = Schema[$decoder]; }\n        if (!constructor.prototype.toJSON) { constructor.prototype.toJSON = Schema.prototype.toJSON; }\n\n        //\n        // detect index for this field, considering inheritance\n        //\n        let fieldIndex = metadata[$numFields] // current structure already has fields defined\n            ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n            ?? -1; // no fields defined\n\n        fieldIndex++;\n\n        for (const field in fields) {\n            const type = fields[field];\n\n            // FIXME: this code is duplicated from @type() annotation\n            const complexTypeKlass = (Array.isArray(type))\n                ? getType(\"array\")\n                : (typeof(Object.keys(type)[0]) === \"string\") && getType(Object.keys(type)[0]);\n\n            const childType = (complexTypeKlass)\n                ? Object.values(type)[0]\n                : getNormalizedType(type);\n\n            Metadata.addField(\n                metadata,\n                fieldIndex,\n                field,\n                type,\n                getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass)\n            );\n\n            fieldIndex++;\n        }\n\n        return target;\n    },\n\n    isDeprecated(metadata: any, field: string) {\n        return metadata[field].deprecated === true;\n    },\n\n    init(klass: any) {\n        //\n        // Used only to initialize an empty Schema (Encoder#constructor)\n        // TODO: remove/refactor this...\n        //\n        const metadata = {};\n        klass[Symbol.metadata] = metadata;\n        Object.defineProperty(metadata, $numFields, {\n            value: 0,\n            enumerable: false,\n            configurable: true,\n        });\n    },\n\n    initialize(constructor: any) {\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata: Metadata = parentClass[Symbol.metadata];\n\n        let metadata: Metadata = constructor[Symbol.metadata] ?? Object.create(null);\n\n        // make sure inherited classes have their own metadata object.\n        if (parentClass !== Schema && metadata === parentMetadata) {\n            metadata = Object.create(null);\n\n            if (parentMetadata) {\n                //\n                // assign parent metadata to current\n                //\n                Object.setPrototypeOf(metadata, parentMetadata);\n\n                // $numFields\n                Object.defineProperty(metadata, $numFields, {\n                    value: parentMetadata[$numFields],\n                    enumerable: false,\n                    configurable: true,\n                    writable: true,\n                });\n\n                // $viewFieldIndexes / $fieldIndexesByViewTag\n                if (parentMetadata[$viewFieldIndexes] !== undefined) {\n                    Object.defineProperty(metadata, $viewFieldIndexes, {\n                        value: [...parentMetadata[$viewFieldIndexes]],\n                        enumerable: false,\n                        configurable: true,\n                        writable: true,\n                    });\n                    Object.defineProperty(metadata, $fieldIndexesByViewTag, {\n                        value: { ...parentMetadata[$fieldIndexesByViewTag] },\n                        enumerable: false,\n                        configurable: true,\n                        writable: true,\n                    });\n                }\n\n                // $refTypeFieldIndexes\n                if (parentMetadata[$refTypeFieldIndexes] !== undefined) {\n                    Object.defineProperty(metadata, $refTypeFieldIndexes, {\n                        value: [...parentMetadata[$refTypeFieldIndexes]],\n                        enumerable: false,\n                        configurable: true,\n                        writable: true,\n                    });\n                }\n\n                // $descriptors\n                Object.defineProperty(metadata, $descriptors, {\n                    value: { ...parentMetadata[$descriptors] },\n                    enumerable: false,\n                    configurable: true,\n                    writable: true,\n                });\n            }\n        }\n\n        constructor[Symbol.metadata] = metadata;\n\n        return metadata;\n    },\n\n    isValidInstance(klass: any) {\n        return (\n            klass.constructor[Symbol.metadata] &&\n            Object.prototype.hasOwnProperty.call(klass.constructor[Symbol.metadata], $numFields) as boolean\n        );\n    },\n\n    getFields(klass: any) {\n        const metadata: Metadata = klass[Symbol.metadata];\n        const fields = {};\n        for (let i = 0; i <= metadata[$numFields]; i++) {\n            fields[metadata[i].name] = metadata[i].type;\n        }\n        return fields;\n    },\n\n    hasViewTagAtIndex(metadata: Metadata, index: number) {\n        return metadata?.[$viewFieldIndexes]?.includes(index);\n    }\n}"]}