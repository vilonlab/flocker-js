{
  "version": 3,
  "sources": ["../src/ClockTimer.ts"],
  "sourcesContent": ["import Clock from \"@colyseus/clock\";\nimport { Delayed, Type } from \"./Delayed.js\";\nimport { TimerClearedError } from \"./TimerClearedError.js\";\n\nexport class ClockTimer extends Clock {\n  /**\n   * An array of all the scheduled timeouts and intervals.\n   * @private For compatibility it's public but avoid modifying it directly.\n   */\n  delayed: Delayed[] = [];\n\n  constructor(autoStart: boolean = false) {\n    super(autoStart);\n  }\n\n  /**\n   * Re-evaluate all the scheduled timeouts and intervals and execute appropriate handlers.\n   * Use this in your own context or not if your passed `autoStart` as `true` in the constructor.\n   */\n  tick() {\n    super.tick();\n\n    let delayedList = this.delayed;\n    let i = delayedList.length;\n\n    while (i--) {\n      const delayed = delayedList[i];\n\n      if (delayed.active) {\n        delayed.tick(this.deltaTime);\n      } else {\n        delayedList.splice(i, 1);\n        continue;\n      }\n    }\n  }\n\n  /**\n   * Schedule a function to be called every `time` milliseconds.\n   * This `time` minimum value will be tied to the `tick` method of the clock. This means if you use the default `autoStart` value from the constructor, the minimum value will be 16ms. Otherwise it will depend on your `tick` method call.\n   *\n   * Returns a {@link Delayed} object that can be used to clear the timeout or play around with it.\n   */\n  setInterval(handler: Function, time: number, ...args: any[]): Delayed {\n    const delayed = new Delayed(handler, args, time, Type.Interval);\n    this.delayed.push(delayed);\n    return delayed;\n  }\n\n  /**\n   * Schedule a function to be called after a delay.\n   *\n   * This `time` minimum value will be tied to the `tick` method of the clock. This means if you use the default `autoStart` value from the constructor, the minimum value will be 16ms. Otherwise it will depend on your `tick` method call.\n   *\n   * Returns a {@link Delayed} object that can be used to clear the timeout or play around with it.\n   */\n  setTimeout(handler: Function, time: number, ...args: any[]): Delayed {\n    const delayed = new Delayed(handler, args, time, Type.Timeout);\n    this.delayed.push(delayed);\n    return delayed;\n  }\n\n  /**\n   * A promise that schedule a timeout that will resolves after the given time.\n   *\n   * If the {@link Delayed} instance is cleared before the time, the promise will be rejected. This happens when the {@link ClockTimer.clear} method is called.\n   *\n   * For the sake of simplicity of this API, you can only cancel a timeout scheduled with this method with {@link ClockTimer.clear} method (which clears all scheduled timeouts and intervals).\n   * If you need fine-tuned control over the timeout, use the {@link ClockTimer.setTimeout} method instead.\n   *\n   * @example **Inside an async function**\n   * ```typescript\n   * const timer = new Clock(true);\n   * await timer.duration(1000);\n   * console.log(\"1 second later\");\n   * ```\n   *\n   * @example **Using the promise**\n   * ```typescript\n   * const timer = new Clock(true);\n   * timer.duration(1000).then(() => console.log(\"1 second later\"));\n   * ```\n   *\n   * @example **Using the promise with error**\n   * ```typescript\n   * const timer = new Clock(true);\n   * timer.duration(1000).then(() => console.log(\"1 second later\")).catch(() => console.log(\"Timer cleared\"));\n   * timer.clear();\n   * ```\n   *\n   *\n   * @param ms the duration in milliseconds in which the promise will be resolved\n   */\n  duration(ms: number): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const delayed = new Delayed(resolve, undefined, ms, Type.Async);\n      delayed.clear = () => {\n        delayed.active = false;\n        reject(new TimerClearedError()); // To be able to use instanceof in try / catch blocks\n      };\n      this.delayed.push(delayed);\n    });\n  }\n\n  /**\n   * Delete any scheduled timeout or interval. That will never be executed.\n   *\n   * If some of the timeouts/intervals are already executed, they will be removed from the list and callback will be garbage collected.\n   * For timeout created with {@link ClockTimer.duration}, the promise will be rejected and therefore the unused resolving callback will be garbage collected.\n   */\n  clear() {\n    let i = this.delayed.length;\n    while (i--) {\n      this.delayed[i].clear();\n    }\n    this.delayed = [];\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,qBAA8B;AAC9B,+BAAkC;AAE3B,MAAM,mBAAmB,aAAAA,QAAM;AAAA,EAOpC,YAAY,YAAqB,OAAO;AACtC,UAAM,SAAS;AAHjB;AAAA;AAAA;AAAA;AAAA,mBAAqB,CAAC;AAAA,EAItB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO;AACL,UAAM,KAAK;AAEX,QAAI,cAAc,KAAK;AACvB,QAAI,IAAI,YAAY;AAEpB,WAAO,KAAK;AACV,YAAM,UAAU,YAAY,CAAC;AAE7B,UAAI,QAAQ,QAAQ;AAClB,gBAAQ,KAAK,KAAK,SAAS;AAAA,MAC7B,OAAO;AACL,oBAAY,OAAO,GAAG,CAAC;AACvB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,SAAmB,SAAiB,MAAsB;AACpE,UAAM,UAAU,IAAI,uBAAQ,SAAS,MAAM,MAAM,oBAAK,QAAQ;AAC9D,SAAK,QAAQ,KAAK,OAAO;AACzB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,WAAW,SAAmB,SAAiB,MAAsB;AACnE,UAAM,UAAU,IAAI,uBAAQ,SAAS,MAAM,MAAM,oBAAK,OAAO;AAC7D,SAAK,QAAQ,KAAK,OAAO;AACzB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiCA,SAAS,IAA2B;AAClC,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,UAAU,IAAI,uBAAQ,SAAS,QAAW,IAAI,oBAAK,KAAK;AAC9D,cAAQ,QAAQ,MAAM;AACpB,gBAAQ,SAAS;AACjB,eAAO,IAAI,2CAAkB,CAAC;AAAA,MAChC;AACA,WAAK,QAAQ,KAAK,OAAO;AAAA,IAC3B,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QAAQ;AACN,QAAI,IAAI,KAAK,QAAQ;AACrB,WAAO,KAAK;AACV,WAAK,QAAQ,CAAC,EAAE,MAAM;AAAA,IACxB;AACA,SAAK,UAAU,CAAC;AAAA,EAClB;AACF;",
  "names": ["Clock"]
}
