{
  "version": 3,
  "sources": ["../node_modules/@colyseus/clock/build/index.mjs", "../src/Delayed.ts", "../src/TimerClearedError.ts", "../src/ClockTimer.ts"],
  "sourcesContent": ["// src/index.ts\nvar Clock = class {\n  // number or NodeJS.Timer\n  constructor(useInterval = false) {\n    this.running = false;\n    this.now = typeof window !== \"undefined\" && window.performance && window.performance.now && window.performance.now.bind(window.performance) || Date.now;\n    this.start(useInterval);\n  }\n  start(useInterval = false) {\n    this.deltaTime = 0;\n    this.currentTime = this.now();\n    this.elapsedTime = 0;\n    this.running = true;\n    if (useInterval) {\n      this._interval = setInterval(this.tick.bind(this), 1e3 / 60);\n    }\n  }\n  stop() {\n    this.running = false;\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n  }\n  tick(newTime = this.now()) {\n    this.deltaTime = newTime - this.currentTime;\n    this.currentTime = newTime;\n    this.elapsedTime += this.deltaTime;\n  }\n};\nexport {\n  Clock as default\n};\n", "export enum Type {\n  Interval,\n  Timeout,\n  Async,\n}\n\nexport class Delayed {\n  public active: boolean = true;\n  public paused: boolean = false;\n\n  public time: number;\n  public elapsedTime: number = 0;\n\n  protected handler: Function;\n  protected args: any;\n  protected type: number;\n\n  constructor(handler: Function, args: any, time: number, type: number) {\n    this.handler = handler;\n    this.args = args;\n    this.time = time;\n    this.type = type;\n  }\n\n  tick(deltaTime: number) {\n    if (this.paused) {\n      return;\n    }\n\n    this.elapsedTime += deltaTime;\n\n    if (this.elapsedTime >= this.time) {\n      this.execute();\n    }\n  }\n\n  execute() {\n    this.handler.apply(this, this.args);\n\n    switch (this.type) {\n      case Type.Timeout:\n      case Type.Async:\n        this.active = false;\n        break;\n      case Type.Interval:\n        this.elapsedTime -= this.time;\n        break;\n    }\n  }\n\n  reset() {\n    this.elapsedTime = 0;\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  resume() {\n    this.paused = false;\n  }\n\n  clear() {\n    this.active = false;\n  }\n}\n", "import type { ClockTimer as Clock } from \"./ClockTimer.js\";\n/**\n * An error that occurs when the promise of a {@link Clock.duration} is rejected because the timer has been cleared by the clock instance.\n */\nexport class TimerClearedError extends Error {\n  constructor() {\n    super(\"Timer has been cleared\");\n  }\n}\n", "import Clock from \"@colyseus/clock\";\nimport { Delayed, Type } from \"./Delayed.js\";\nimport { TimerClearedError } from \"./TimerClearedError.js\";\n\nexport class ClockTimer extends Clock {\n  /**\n   * An array of all the scheduled timeouts and intervals.\n   * @private For compatibility it's public but avoid modifying it directly.\n   */\n  delayed: Delayed[] = [];\n\n  constructor(autoStart: boolean = false) {\n    super(autoStart);\n  }\n\n  /**\n   * Re-evaluate all the scheduled timeouts and intervals and execute appropriate handlers.\n   * Use this in your own context or not if your passed `autoStart` as `true` in the constructor.\n   */\n  tick() {\n    super.tick();\n\n    let delayedList = this.delayed;\n    let i = delayedList.length;\n\n    while (i--) {\n      const delayed = delayedList[i];\n\n      if (delayed.active) {\n        delayed.tick(this.deltaTime);\n      } else {\n        delayedList.splice(i, 1);\n        continue;\n      }\n    }\n  }\n\n  /**\n   * Schedule a function to be called every `time` milliseconds.\n   * This `time` minimum value will be tied to the `tick` method of the clock. This means if you use the default `autoStart` value from the constructor, the minimum value will be 16ms. Otherwise it will depend on your `tick` method call.\n   *\n   * Returns a {@link Delayed} object that can be used to clear the timeout or play around with it.\n   */\n  setInterval(handler: Function, time: number, ...args: any[]): Delayed {\n    const delayed = new Delayed(handler, args, time, Type.Interval);\n    this.delayed.push(delayed);\n    return delayed;\n  }\n\n  /**\n   * Schedule a function to be called after a delay.\n   *\n   * This `time` minimum value will be tied to the `tick` method of the clock. This means if you use the default `autoStart` value from the constructor, the minimum value will be 16ms. Otherwise it will depend on your `tick` method call.\n   *\n   * Returns a {@link Delayed} object that can be used to clear the timeout or play around with it.\n   */\n  setTimeout(handler: Function, time: number, ...args: any[]): Delayed {\n    const delayed = new Delayed(handler, args, time, Type.Timeout);\n    this.delayed.push(delayed);\n    return delayed;\n  }\n\n  /**\n   * A promise that schedule a timeout that will resolves after the given time.\n   *\n   * If the {@link Delayed} instance is cleared before the time, the promise will be rejected. This happens when the {@link ClockTimer.clear} method is called.\n   *\n   * For the sake of simplicity of this API, you can only cancel a timeout scheduled with this method with {@link ClockTimer.clear} method (which clears all scheduled timeouts and intervals).\n   * If you need fine-tuned control over the timeout, use the {@link ClockTimer.setTimeout} method instead.\n   *\n   * @example **Inside an async function**\n   * ```typescript\n   * const timer = new Clock(true);\n   * await timer.duration(1000);\n   * console.log(\"1 second later\");\n   * ```\n   *\n   * @example **Using the promise**\n   * ```typescript\n   * const timer = new Clock(true);\n   * timer.duration(1000).then(() => console.log(\"1 second later\"));\n   * ```\n   *\n   * @example **Using the promise with error**\n   * ```typescript\n   * const timer = new Clock(true);\n   * timer.duration(1000).then(() => console.log(\"1 second later\")).catch(() => console.log(\"Timer cleared\"));\n   * timer.clear();\n   * ```\n   *\n   *\n   * @param ms the duration in milliseconds in which the promise will be resolved\n   */\n  duration(ms: number): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const delayed = new Delayed(resolve, undefined, ms, Type.Async);\n      delayed.clear = () => {\n        delayed.active = false;\n        reject(new TimerClearedError()); // To be able to use instanceof in try / catch blocks\n      };\n      this.delayed.push(delayed);\n    });\n  }\n\n  /**\n   * Delete any scheduled timeout or interval. That will never be executed.\n   *\n   * If some of the timeouts/intervals are already executed, they will be removed from the list and callback will be garbage collected.\n   * For timeout created with {@link ClockTimer.duration}, the promise will be rejected and therefore the unused resolving callback will be garbage collected.\n   */\n  clear() {\n    let i = this.delayed.length;\n    while (i--) {\n      this.delayed[i].clear();\n    }\n    this.delayed = [];\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
