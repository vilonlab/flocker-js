{"version":3,"file":"Reflection.js","sourceRoot":"","sources":["../src/Reflection.ts"],"names":[],"mappings":"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","sourcesContent":["import { type, PrimitiveType } from \"./annotations\";\nimport { TypeContext } from \"./types/TypeContext\";\nimport { Metadata } from \"./Metadata\";\nimport { ArraySchema } from \"./types/custom/ArraySchema\";\nimport { Iterator } from \"./encoding/decode\";\nimport { Encoder } from \"./encoder/Encoder\";\nimport { Decoder } from \"./decoder/Decoder\";\nimport { Schema } from \"./Schema\";\n\n/**\n * Reflection\n */\nexport class ReflectionField extends Schema {\n    @type(\"string\") name: string;\n    @type(\"string\") type: string;\n    @type(\"number\") referencedType: number;\n}\n\nexport class ReflectionType extends Schema {\n    @type(\"number\") id: number;\n    @type(\"number\") extendsId: number;\n    @type([ ReflectionField ]) fields = new ArraySchema<ReflectionField>();\n}\n\nexport class Reflection extends Schema {\n    @type([ReflectionType]) types: ArraySchema<ReflectionType> = new ArraySchema<ReflectionType>();\n    @type(\"number\") rootType: number;\n\n    /**\n     * Encodes the TypeContext of an Encoder into a buffer.\n     *\n     * @param encoder Encoder instance\n     * @param it\n     * @returns\n     */\n    static encode(encoder: Encoder, it: Iterator = { offset: 0 }) {\n        const context = encoder.context;\n\n        const reflection = new Reflection();\n        const reflectionEncoder = new Encoder(reflection);\n\n        // rootType is usually the first schema passed to the Encoder\n        // (unless it inherits from another schema)\n        const rootType = context.schemas.get(encoder.state.constructor);\n        if (rootType > 0) { reflection.rootType = rootType; }\n\n        const includedTypeIds = new Set<number>();\n        const pendingReflectionTypes: { [typeid: number]: ReflectionType[] } = {};\n\n        // add type to reflection in a way that respects inheritance\n        // (parent types should be added before their children)\n        const addType = (type: ReflectionType) => {\n            if (type.extendsId === undefined || includedTypeIds.has(type.extendsId)) {\n                includedTypeIds.add(type.id);\n\n                reflection.types.push(type);\n\n                const deps = pendingReflectionTypes[type.id];\n                if (deps !== undefined) {\n                    delete pendingReflectionTypes[type.id];\n                    deps.forEach((childType) => addType(childType));\n                }\n            } else {\n                if (pendingReflectionTypes[type.extendsId] === undefined) {\n                    pendingReflectionTypes[type.extendsId] = [];\n                }\n                pendingReflectionTypes[type.extendsId].push(type);\n            }\n        };\n\n        context.schemas.forEach((typeid, klass) => {\n            const type = new ReflectionType();\n            type.id = Number(typeid);\n\n            // support inheritance\n            const inheritFrom = Object.getPrototypeOf(klass);\n            if (inheritFrom !== Schema) {\n                type.extendsId = context.schemas.get(inheritFrom);\n            }\n\n            const metadata = klass[Symbol.metadata];\n\n            //\n            // FIXME: this is a workaround for inherited types without additional fields\n            // if metadata is the same reference as the parent class - it means the class has no own metadata\n            //\n            if (metadata !== inheritFrom[Symbol.metadata]) {\n                for (const fieldIndex in metadata) {\n                    const index = Number(fieldIndex);\n                    const fieldName = metadata[index].name;\n\n                    // skip fields from parent classes\n                    if (!Object.prototype.hasOwnProperty.call(metadata, fieldName)) {\n                        continue;\n                    }\n\n                    const reflectionField = new ReflectionField();\n                    reflectionField.name = fieldName;\n\n                    let fieldType: string;\n\n                    const field = metadata[index];\n\n                    if (typeof (field.type) === \"string\") {\n                        fieldType = field.type;\n\n                    } else {\n                        let childTypeSchema: typeof Schema;\n\n                        //\n                        // TODO: refactor below.\n                        //\n                        if (Schema.is(field.type)) {\n                            fieldType = \"ref\";\n                            childTypeSchema = field.type as typeof Schema;\n\n                        } else {\n                            fieldType = Object.keys(field.type)[0];\n\n                            if (typeof (field.type[fieldType]) === \"string\") {\n                                fieldType += \":\" + field.type[fieldType]; // array:string\n\n                            } else {\n                                childTypeSchema = field.type[fieldType];\n                            }\n                        }\n\n                        reflectionField.referencedType = (childTypeSchema)\n                            ? context.getTypeId(childTypeSchema)\n                            : -1;\n                    }\n\n                    reflectionField.type = fieldType;\n                    type.fields.push(reflectionField);\n                }\n            }\n\n            addType(type);\n        });\n\n        // in case there are types that were not added due to inheritance\n        for (const typeid in pendingReflectionTypes) {\n            pendingReflectionTypes[typeid].forEach((type) =>\n                reflection.types.push(type))\n        }\n\n        const buf = reflectionEncoder.encodeAll(it);\n        return Buffer.from(buf, 0, it.offset);\n    }\n\n    /**\n     * Decodes the TypeContext from a buffer into a Decoder instance.\n     *\n     * @param bytes Reflection.encode() output\n     * @param it\n     * @returns Decoder instance\n     */\n    static decode<T extends Schema = Schema>(bytes: Buffer, it?: Iterator): Decoder<T> {\n        const reflection = new Reflection();\n\n        const reflectionDecoder = new Decoder(reflection);\n        reflectionDecoder.decode(bytes, it);\n\n        const typeContext = new TypeContext();\n\n        // 1st pass, initialize metadata + inheritance\n        reflection.types.forEach((reflectionType) => {\n            const parentClass: typeof Schema = typeContext.get(reflectionType.extendsId) ?? Schema;\n            const schema: typeof Schema = class _ extends parentClass {};\n\n            // register for inheritance support\n            TypeContext.register(schema);\n\n            // // for inheritance support\n            // Metadata.initialize(schema);\n\n            typeContext.add(schema, reflectionType.id);\n        }, {});\n\n        // define fields\n        const addFields = (metadata: Metadata, reflectionType: ReflectionType, parentFieldIndex: number) => {\n            reflectionType.fields.forEach((field, i) => {\n                const fieldIndex = parentFieldIndex + i;\n\n                if (field.referencedType !== undefined) {\n                    let fieldType = field.type;\n                    let refType: PrimitiveType = typeContext.get(field.referencedType);\n\n                    // map or array of primitive type (-1)\n                    if (!refType) {\n                        const typeInfo = field.type.split(\":\");\n                        fieldType = typeInfo[0];\n                        refType = typeInfo[1] as PrimitiveType; // string\n                    }\n\n                    if (fieldType === \"ref\") {\n                        Metadata.addField(metadata, fieldIndex, field.name, refType);\n\n                    } else {\n                        Metadata.addField(metadata, fieldIndex, field.name, { [fieldType]: refType });\n                    }\n\n                } else {\n                    Metadata.addField(metadata, fieldIndex, field.name, field.type as PrimitiveType);\n                }\n            });\n        };\n\n        // 2nd pass, set fields\n        reflection.types.forEach((reflectionType) => {\n            const schema = typeContext.get(reflectionType.id);\n\n            // for inheritance support\n            const metadata = Metadata.initialize(schema);\n\n            const inheritedTypes: ReflectionType[] = [];\n\n            let parentType: ReflectionType = reflectionType;\n            do {\n                inheritedTypes.push(parentType);\n                parentType = reflection.types.find((t) => t.id === parentType.extendsId);\n            } while (parentType);\n\n            let parentFieldIndex = 0;\n\n            inheritedTypes.reverse().forEach((reflectionType) => {\n                // add fields from all inherited classes\n                // TODO: refactor this to avoid adding fields from parent classes\n                addFields(metadata, reflectionType, parentFieldIndex);\n                parentFieldIndex += reflectionType.fields.length;\n            });\n        });\n\n        const state: T = new (typeContext.get(reflection.rootType || 0) as unknown as any)();\n\n        return new Decoder<T>(state, typeContext);\n    }\n}\n"]}