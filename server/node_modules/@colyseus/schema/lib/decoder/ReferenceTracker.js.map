{"version":3,"file":"ReferenceTracker.js","sourceRoot":"","sources":["../../src/decoder/ReferenceTracker.ts"],"names":[],"mappings":"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","sourcesContent":["import { Metadata } from \"../Metadata\";\nimport { $childType } from \"../types/symbols\";\nimport { Ref } from \"../encoder/ChangeTree\";\nimport { spliceOne } from \"../types/utils\";\nimport type { MapSchema } from \"../types/custom/MapSchema\";\nimport { OPERATION } from \"../encoding/spec\";\n\nclass DecodingWarning extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"DecodingWarning\";\n    }\n}\n\n/**\n * Used for decoding only.\n */\n\nexport type SchemaCallbacks = { [field: string | number]: Function[] };\n\nexport class ReferenceTracker {\n    //\n    // Relation of refId => Schema structure\n    // For direct access of structures during decoding time.\n    //\n    public refs = new Map<number, Ref>();\n    public refIds = new WeakMap<Ref, number>();\n\n    public refCounts: { [refId: number]: number; } = {};\n    public deletedRefs = new Set<number>();\n\n    public callbacks: { [refId: number]: SchemaCallbacks } = {};\n    protected nextUniqueId: number = 0;\n\n    getNextUniqueId() {\n        return this.nextUniqueId++;\n    }\n\n    // for decoding\n    addRef(refId: number, ref: Ref, incrementCount: boolean = true) {\n        this.refs.set(refId, ref);\n        this.refIds.set(ref, refId);\n\n        if (incrementCount) {\n            this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;\n        }\n\n        if (this.deletedRefs.has(refId)) {\n            this.deletedRefs.delete(refId);\n        }\n    }\n\n    // for decoding\n    removeRef(refId: number) {\n        const refCount = this.refCounts[refId];\n\n        if (refCount === undefined) {\n            try {\n                throw new DecodingWarning(\"trying to remove refId that doesn't exist: \" + refId);\n            } catch (e) {\n                console.warn(e);\n            }\n            return;\n        }\n\n        if (refCount === 0) {\n            try {\n                const ref = this.refs.get(refId);\n                throw new DecodingWarning(`trying to remove refId '${refId}' with 0 refCount (${ref.constructor.name}: ${JSON.stringify(ref)})`);\n            } catch (e) {\n                console.warn(e);\n            }\n            return;\n        }\n\n        if ((this.refCounts[refId] = refCount - 1) <= 0) {\n            this.deletedRefs.add(refId);\n        }\n    }\n\n    clearRefs() {\n        this.refs.clear();\n        this.deletedRefs.clear();\n        this.callbacks = {};\n        this.refCounts = {};\n    }\n\n    // for decoding\n    garbageCollectDeletedRefs() {\n        this.deletedRefs.forEach((refId) => {\n            //\n            // Skip active references.\n            //\n            if (this.refCounts[refId] > 0) { return; }\n\n            const ref = this.refs.get(refId);\n\n            //\n            // Ensure child schema instances have their references removed as well.\n            //\n            if (ref.constructor[Symbol.metadata] !== undefined) {\n                const metadata: Metadata = ref.constructor[Symbol.metadata];\n                for (const index in metadata) {\n                    const field = metadata[index as any as number].name;\n                    const childRefId = typeof(ref[field]) === \"object\" && this.refIds.get(ref[field]);\n                    if (childRefId && !this.deletedRefs.has(childRefId)) {\n                        this.removeRef(childRefId);\n                    }\n                }\n\n            } else {\n                if (typeof (ref[$childType]) === \"function\") {\n                    Array.from((ref as MapSchema).values())\n                        .forEach((child) => {\n                            const childRefId = this.refIds.get(child);\n                            if (!this.deletedRefs.has(childRefId)) {\n                                this.removeRef(childRefId);\n                            }\n                        });\n                }\n            }\n\n            this.refs.delete(refId); // remove ref\n            delete this.refCounts[refId]; // remove ref count\n            delete this.callbacks[refId]; // remove callbacks\n        });\n\n        // clear deleted refs.\n        this.deletedRefs.clear();\n    }\n\n    addCallback(refId: number, fieldOrOperation: string | number, callback: Function) {\n        if (refId === undefined) {\n            const name = (typeof(fieldOrOperation) === \"number\")\n                    ? OPERATION[fieldOrOperation]\n                    : fieldOrOperation\n            throw new Error(\n                `Can't addCallback on '${name}' (refId is undefined)`\n            );\n        }\n        if (!this.callbacks[refId]) {\n            this.callbacks[refId] = {};\n        }\n        if (!this.callbacks[refId][fieldOrOperation]) {\n            this.callbacks[refId][fieldOrOperation] = [];\n        }\n        this.callbacks[refId][fieldOrOperation].push(callback);\n        return () => this.removeCallback(refId, fieldOrOperation, callback);\n    }\n\n    removeCallback(refId: number, field: string | number, callback: Function) {\n        const index = this.callbacks?.[refId]?.[field]?.indexOf(callback);\n        if (index !== -1) {\n            spliceOne(this.callbacks[refId][field], index);\n        }\n    }\n\n}\n"]}