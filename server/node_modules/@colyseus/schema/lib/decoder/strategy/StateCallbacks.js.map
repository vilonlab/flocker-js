{"version":3,"file":"StateCallbacks.js","sourceRoot":"","sources":["../../../src/decoder/strategy/StateCallbacks.ts"],"names":[],"mappings":"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","sourcesContent":["import { Metadata } from \"../../Metadata\";\nimport { Collection, NonFunctionNonPrimitivePropNames, NonFunctionPropNames } from \"../../types/HelperTypes\";\nimport { Ref } from \"../../encoder/ChangeTree\";\nimport { Decoder } from \"../Decoder\";\nimport { DataChange } from \"../DecodeOperation\";\nimport { OPERATION } from \"../../encoding/spec\";\nimport { Schema } from \"../../Schema\";\nimport type { DefinitionType } from \"../../annotations\";\nimport type { CollectionSchema } from \"../../types/custom/CollectionSchema\";\n\n//\n// Discussion: https://github.com/colyseus/schema/issues/155\n//\n// Main points:\n// - Decouple structures from their callbacks.\n// - Registering deep callbacks can be confusing.\n// - Avoid closures by allowing to pass a context. (https://github.com/colyseus/schema/issues/155#issuecomment-1804694081)\n//\n\nexport type SchemaCallbackProxy<RoomState> = (<T extends Schema>(instance: T) => CallbackProxy<T>);\nexport type GetCallbackProxy = SchemaCallbackProxy<any>; // workaround for compatibility for < colyseus.js0.16.6. Remove me on next major release.\n\nexport type CallbackProxy<T> = unknown extends T // is \"any\"?\n    ? SchemaCallback<T> & CollectionCallback<any, any>\n    : T extends Collection<infer K, infer V, infer _>\n        ? CollectionCallback<K, V>\n        : SchemaCallback<T>;\n\nexport type SchemaCallback<T> = {\n    /**\n     * Trigger callback when value of a property changes.\n     *\n     * @param prop name of the property\n     * @param callback callback to be triggered on property change\n     * @param immediate trigger immediatelly if property has been already set.\n     * @return callback to detach the listener\n     */\n    listen<K extends NonFunctionPropNames<T>>(\n        prop: K,\n        callback: (value: T[K], previousValue: T[K]) => void,\n        immediate?: boolean,\n    ): () => void;\n\n    /**\n     * Trigger callback whenever any property changed within this instance.\n     *\n     * @param prop name of the property\n     * @param callback callback to be triggered on property change\n     * @param immediate trigger immediatelly if property has been already set.\n     * @return callback to detach the listener\n     */\n    onChange(callback: () => void): () => void;\n\n    /**\n     * Bind properties to another object. Changes on the properties will be reflected on the target object.\n     *\n     * @param targetObject object to bind properties to\n     * @param properties list of properties to bind. If not provided, all properties will be bound.\n     */\n    bindTo(targetObject: any, properties?: Array<NonFunctionPropNames<T>>): void;\n} & {\n    [K in NonFunctionNonPrimitivePropNames<T>]: CallbackProxy<T[K]>;\n}\n\nexport type CollectionCallback<K, V> = {\n    /**\n     * Trigger callback when an item has been added to the collection.\n     *\n     * @param callback\n     * @param immediate\n     * @return callback to detach the onAdd listener\n     */\n    onAdd(callback: (item: V, index: K) => void, immediate?: boolean): () => void;\n\n    /**\n     * Trigger callback when an item has been removed to the collection.\n     *\n     * @param callback\n     * @return callback to detach the onRemove listener\n     */\n    onRemove(callback: (item: V, index: K) => void): () => void;\n\n    /**\n     * Trigger callback when the value on a key has changed.\n     *\n     * THIS METHOD IS NOT RECURSIVE!\n     * If you want to listen to changes on individual items, you need to attach callbacks to the them directly inside the `onAdd` callback.\n     *\n     * @param callback\n     */\n    onChange(callback: (item: V, index: K) => void): void;\n};\n\ntype OnInstanceAvailableCallback = (callback: (ref: Ref, existing: boolean) => void) => void;\n\ntype CallContext = {\n    instance?: any,\n    parentInstance?: any,\n    onInstanceAvailable?: OnInstanceAvailableCallback,\n}\n\n\nexport function getDecoderStateCallbacks<T extends Schema>(decoder: Decoder<T>): SchemaCallbackProxy<T> {\n    const $root = decoder.root;\n    const callbacks = $root.callbacks;\n\n    const onAddCalls: WeakMap<Function, boolean> = new WeakMap();\n    let currentOnAddCallback: Function | undefined;\n\n    decoder.triggerChanges = function (allChanges: DataChange[]) {\n        const uniqueRefIds = new Set<number>();\n\n        for (let i = 0, l = allChanges.length; i < l; i++) {\n            const change = allChanges[i];\n            const refId = change.refId;\n            const ref = change.ref;\n            const $callbacks = callbacks[refId];\n\n            if (!$callbacks) { continue; }\n\n            //\n            // trigger onRemove on child structure.\n            //\n            if (\n                (change.op & OPERATION.DELETE) === OPERATION.DELETE &&\n                change.previousValue instanceof Schema\n            ) {\n                const deleteCallbacks = callbacks[$root.refIds.get(change.previousValue)]?.[OPERATION.DELETE];\n                for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {\n                    deleteCallbacks[i]();\n                }\n            }\n\n            if (ref instanceof Schema) {\n                //\n                // Handle schema instance\n                //\n\n                if (!uniqueRefIds.has(refId)) {\n                    // trigger onChange\n                    const replaceCallbacks = $callbacks?.[OPERATION.REPLACE];\n                    for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {\n                        replaceCallbacks[i]();\n                        // try {\n                        // } catch (e) {\n                        //     console.error(e);\n                        // }\n                    }\n                }\n\n                if ($callbacks.hasOwnProperty(change.field)) {\n                    const fieldCallbacks = $callbacks[change.field];\n                    for (let i = fieldCallbacks?.length - 1; i >= 0; i--) {\n                        fieldCallbacks[i](change.value, change.previousValue);\n                        // try {\n                        // } catch (e) {\n                        //     console.error(e);\n                        // }\n                    }\n                }\n\n\n            } else {\n                //\n                // Handle collection of items\n                //\n\n                if ((change.op & OPERATION.DELETE) === OPERATION.DELETE) {\n                    //\n                    // FIXME: `previousValue` should always be available.\n                    //\n                    if (change.previousValue !== undefined) {\n                        // triger onRemove\n                        const deleteCallbacks = $callbacks[OPERATION.DELETE];\n                        for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {\n                            deleteCallbacks[i](change.previousValue, change.dynamicIndex ?? change.field);\n                        }\n                    }\n\n                    // Handle DELETE_AND_ADD operations\n                    if ((change.op & OPERATION.ADD) === OPERATION.ADD) {\n                        const addCallbacks = $callbacks[OPERATION.ADD];\n                        for (let i = addCallbacks?.length - 1; i >= 0; i--) {\n                            addCallbacks[i](change.value, change.dynamicIndex ?? change.field);\n                        }\n                    }\n\n                } else if ((change.op & OPERATION.ADD) === OPERATION.ADD && change.previousValue === undefined) {\n                    // triger onAdd\n                    const addCallbacks = $callbacks[OPERATION.ADD];\n                    for (let i = addCallbacks?.length - 1; i >= 0; i--) {\n                        addCallbacks[i](change.value, change.dynamicIndex ?? change.field);\n                    }\n                }\n\n                // trigger onChange\n                if (\n                    change.value !== change.previousValue &&\n                    // FIXME: see \"should not encode item if added and removed at the same patch\" test case.\n                    // some \"ADD\" + \"DELETE\" operations on same patch are being encoded as \"DELETE\"\n                    (change.value !== undefined || change.previousValue !== undefined)\n                ) {\n                    const replaceCallbacks = $callbacks[OPERATION.REPLACE];\n                    for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {\n                        replaceCallbacks[i](change.value, change.dynamicIndex ?? change.field);\n                    }\n                }\n            }\n\n            uniqueRefIds.add(refId);\n        }\n    };\n\n    function getProxy(\n        metadataOrType: Metadata | DefinitionType,\n        context: CallContext\n    ) {\n        let metadata: Metadata = context.instance?.constructor[Symbol.metadata] || metadataOrType;\n        let isCollection = (\n            (context.instance && typeof (context.instance['forEach']) === \"function\") ||\n            (metadataOrType && typeof (metadataOrType[Symbol.metadata]) === \"undefined\")\n        );\n\n        if (metadata && !isCollection) {\n\n            const onAddListen = function (\n                ref: Ref,\n                prop: string,\n                callback: (value: any, previousValue: any) => void, immediate: boolean\n            ) {\n                // immediate trigger\n                if (\n                    immediate &&\n                    context.instance[prop] !== undefined &&\n                    !onAddCalls.has(currentOnAddCallback) // Workaround for https://github.com/colyseus/schema/issues/147\n                ) {\n                    callback(context.instance[prop], undefined);\n                }\n                return $root.addCallback($root.refIds.get(ref), prop, callback);\n            }\n\n            /**\n             * Schema instances\n             */\n            return new Proxy({\n                listen: function listen(prop: string, callback: (value: any, previousValue: any) => void, immediate: boolean = true) {\n                    if (context.instance) {\n                        return onAddListen(context.instance, prop, callback, immediate);\n\n                    } else {\n                        // collection instance not received yet\n                        let detachCallback = () => {};\n\n                        context.onInstanceAvailable((ref: Ref, existing: boolean) => {\n                            detachCallback = onAddListen(ref, prop, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback))\n                        });\n\n                        return () => detachCallback();\n                    }\n                },\n\n                onChange: function onChange(callback: () => void) {\n                    return $root.addCallback(\n                        $root.refIds.get(context.instance),\n                        OPERATION.REPLACE,\n                        callback\n                    );\n                },\n\n                //\n                // TODO: refactor `bindTo()` implementation.\n                // There is room for improvement.\n                //\n                bindTo: function bindTo(targetObject: any, properties?: string[]) {\n                    if (!properties) {\n                        properties = Object.keys(metadata).map((index) => metadata[index as any as number].name);\n                    }\n                    return $root.addCallback(\n                        $root.refIds.get(context.instance),\n                        OPERATION.REPLACE,\n                        () => {\n                            properties.forEach((prop) =>\n                                targetObject[prop] = context.instance[prop])\n                        }\n                    );\n                }\n            }, {\n                get(target, prop: string) {\n                    const metadataField = metadata[metadata[prop]];\n                    if (metadataField) {\n                        const instance = context.instance?.[prop];\n                        const onInstanceAvailable: OnInstanceAvailableCallback = (\n                            (callback: (ref: Ref, existing: boolean) => void) => {\n                                const unbind = $(context.instance).listen(prop, (value, _) => {\n                                    callback(value, false);\n\n                                    // FIXME: by \"unbinding\" the callback here,\n                                    // it will not support when the server\n                                    // re-instantiates the instance.\n                                    //\n                                    unbind?.();\n                                }, false);\n\n                                // has existing value\n                                if ($root.refIds.get(instance) !== undefined) {\n                                    callback(instance, true);\n                                }\n                            }\n                        );\n\n                        return getProxy(metadataField.type, {\n                            // make sure refId is available, otherwise need to wait for the instance to be available.\n                            instance: ($root.refIds.get(instance) && instance),\n                            parentInstance: context.instance,\n                            onInstanceAvailable,\n                        });\n\n                    } else {\n                        // accessing the function\n                        return target[prop];\n                    }\n                },\n                has(target, prop: string) { return metadata[prop] !== undefined; },\n                set(_, _1, _2) { throw new Error(\"not allowed\"); },\n                deleteProperty(_, _1) { throw new Error(\"not allowed\"); },\n            });\n\n        } else {\n            /**\n             * Collection instances\n             */\n\n            const onAdd = function (ref: Ref, callback: (value: any, key: any) => void, immediate: boolean) {\n                // Trigger callback on existing items\n                if (immediate) {\n                    (ref as CollectionSchema).forEach((v, k) => callback(v, k));\n                }\n\n                return $root.addCallback($root.refIds.get(ref), OPERATION.ADD, (value, key) => {\n                    onAddCalls.set(callback, true);\n                    currentOnAddCallback = callback;\n                    callback(value, key);\n                    onAddCalls.delete(callback)\n                    currentOnAddCallback = undefined;\n                });\n            };\n\n            const onRemove = function (ref: Ref, callback: (value: any, key: any) => void) {\n                return $root.addCallback($root.refIds.get(ref), OPERATION.DELETE, callback);\n            };\n\n            const onChange = function (ref: Ref, callback: (value: any, key: any) => void) {\n                return $root.addCallback($root.refIds.get(ref), OPERATION.REPLACE, callback);\n            };\n\n            return new Proxy({\n                onAdd: function(callback: (value, key) => void, immediate: boolean = true) {\n                    //\n                    // https://github.com/colyseus/schema/issues/147\n                    // If parent instance has \"onAdd\" registered, avoid triggering immediate callback.\n                    //\n\n                    if (context.instance) {\n                        return onAdd(context.instance, callback, immediate && !onAddCalls.has(currentOnAddCallback));\n\n                    } else if (context.onInstanceAvailable) {\n                        // collection instance not received yet\n                        let detachCallback = () => {};\n\n                        context.onInstanceAvailable((ref: Ref, existing: boolean) => {\n                            detachCallback = onAdd(ref, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback));\n                        });\n\n                        return () => detachCallback();\n                    }\n                },\n                onRemove: function(callback: (value, key) => void) {\n                    if (context.instance) {\n                        return onRemove(context.instance, callback);\n\n                    } else if (context.onInstanceAvailable) {\n                        // collection instance not received yet\n                        let detachCallback = () => {};\n\n                        context.onInstanceAvailable((ref: Ref) => {\n                            detachCallback = onRemove(ref, callback)\n                        });\n\n                        return () => detachCallback();\n                    }\n                },\n                onChange: function(callback: (value, key) => void) {\n                    if (context.instance) {\n                        return onChange(context.instance, callback);\n\n                    } else if (context.onInstanceAvailable) {\n                        // collection instance not received yet\n                        let detachCallback = () => {};\n\n                        context.onInstanceAvailable((ref: Ref) => {\n                            detachCallback = onChange(ref, callback)\n                        });\n\n                        return () => detachCallback();\n                    }\n                },\n            }, {\n                get(target, prop: string) {\n                    if (!target[prop]) {\n                        throw new Error(`Can't access '${prop}' through callback proxy. access the instance directly.`);\n                    }\n                    return target[prop];\n                },\n                has(target, prop) { return target[prop] !== undefined; },\n                set(_, _1, _2) { throw new Error(\"not allowed\"); },\n                deleteProperty(_, _1) { throw new Error(\"not allowed\"); },\n            });\n        }\n    }\n\n    function $<T>(instance: T): CallbackProxy<T> {\n        return getProxy(undefined, { instance }) as unknown as CallbackProxy<T>;\n    }\n\n    return $;\n}"]}