{
  "version": 3,
  "sources": ["../src/ServerResponse.ts"],
  "sourcesContent": ["import fs from \"fs\";\nimport mime from \"mime\";\nimport EventEmitter from \"events\";\nimport uWS, { RecognizedString } from \"uWebSockets.js\";\nimport { ReasonPhrases, StatusCodes } from \"http-status-codes\";\nimport { response, CookieOptions } from \"express\";\nimport http from \"http\";\nimport merge from \"utils-merge\";\nimport cookie from \"cookie\";\nimport { sign } from 'cookie-signature';\n\nexport class ServerResponse extends EventEmitter /* implements http.ServerResponse */ {\n  private _headers: { [name: string]: string | string[] } = {};\n  private _writes: any[] = [];\n\n  public statusCode: number = 200;\n  public headersSent: boolean = false;\n  public finished: boolean = false;\n  public aborted: boolean;\n  public locals: any = {};\n\n  public writableEnded = false;\n\n  constructor(\n    private res: uWS.HttpResponse,\n    private req: any,\n    private app: any,\n  ) {\n    super();\n    http.OutgoingMessage.call(this);\n  }\n\n  render(view: string, options?: any, callback?: (err: Error, html: string) => void): void\n  render(view: string, callback?: (err: Error, html: string) => void): void {\n    response.render.apply(this, arguments);\n  }\n\n  end(chunk?: string, encoding?: BufferEncoding) {\n    if (this.finished) { return; }\n\n    let body = chunk;\n    if (encoding) { body = Buffer.from(chunk, encoding).toString(); }\n\n    if (!this.writableEnded) {\n      // write status + headers\n      this.writeHead(this.statusCode || this.statusCode, this._headers);\n\n      // write response\n      this.res.cork(() => {\n        // dequeue writes\n        this._writes.forEach((chunk) => this.res.write(chunk));\n\n        this.res.end(body);\n      });\n    }\n\n    // this.writableEnded = true;\n\n    this.finished = true;\n    this.emit('finish');\n\n    return this;\n  }\n\n  get(name: string) {\n    return this._headers[name.toLowerCase()];\n  }\n\n  hasHeader(name: string) {\n    return (this._headers[name.toLowerCase()] !== undefined);\n  }\n\n  getHeader(name: string) {\n    this.get(name);\n  }\n\n  setHeader(name: string, value: string | string[]) {\n    this.set(name, value);\n  }\n\n  removeHeader(name: string) {\n    delete this._headers[name.toLowerCase()];\n  }\n\n  status(code: number) {\n    this.statusCode = code;\n    return this;\n  }\n\n  sendStatus(statusCode: number) {\n    this.status(statusCode);\n    return this;\n  }\n\n  vary (field: string) {\n    let append = \"\";\n\n    if (!this._headers['vary']) {\n      this._headers['vary'] = \"\";\n      append = field;\n\n    } else {\n      append = `, ${field}`;\n    }\n\n    this._headers['vary'] += append;\n  }\n\n  sendFile(path: string, fn?: (err: Error) => void): void {\n    this.type(path);\n    fs.readFile(path, (err, contents) => {\n      if (err) return fn(err);\n      this.send(contents);\n    });\n  }\n\n  send(chunk?: RecognizedString) {\n    switch (typeof chunk) {\n      // string defaulting to html\n      case 'string':\n        if (!this.get('Content-Type')) {\n          this.type('html');\n        }\n        break;\n      case 'boolean':\n      case 'number':\n      case 'object':\n        if (chunk === null) {\n          chunk = '';\n        } else if (Buffer.isBuffer(chunk)) {\n          if (!this.get('Content-Type')) {\n            this.type('bin');\n          }\n        } else {\n          return this.json(chunk);\n        }\n        break;\n    }\n\n    return this.end(chunk as string);\n  }\n\n  // enqueue to write during .end()\n  write(chunk: RecognizedString) {\n    this._writes.push(chunk);\n    return this;\n  }\n\n  type(type: string) {\n    this.set('Content-Type', mime.getType(type) || type);\n    return this;\n  }\n\n  json(body: any) {\n    this.type('json').end(JSON.stringify(body));\n  }\n\n  jsonp(body: any) {\n    this.set('Content-Type', \"application/javascript\");\n    this.end(`callback(${JSON.stringify(body)})`);\n  }\n\n  location(url: string) {\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location\n    return response.location.apply(this, arguments);\n  }\n\n  redirect(path: string)\n  redirect(code: number, path: string)\n  redirect(codeOrPath: number | string, path?: string) {\n    return response.redirect.apply(this, arguments);\n    // if (arguments.length === 1) {\n    //   path = codeOrPath as string;\n    //   codeOrPath = 302;\n    // }\n\n    // this.\n    //   status(codeOrPath as number).\n    //   location(path).\n    //   end();\n  }\n\n  format(obj: any) {\n    return response.format.apply(this, arguments);\n  }\n\n  set(name: string | object, value?: string | string[]) {\n    if (typeof(name) === \"string\") {\n      name = name.toLowerCase();\n      if (name !== 'content-length') {\n        this._headers[name] = value;\n      }\n\n    } else {\n      for (let _name in name) {\n        _name = _name.toLowerCase();\n        if (_name !== 'content-length') {\n          this._headers[_name] = name[_name];\n        }\n      }\n    }\n    return this;\n  }\n\n  append(name: string, val: string | string[]) {\n    const prev = this.get(name);\n    let value = val;\n    if (prev) {\n      // concat the new and prev vals\n      value = Array.isArray(prev) ? prev.concat(val)\n        : Array.isArray(val) ? [prev].concat(val)\n        : [prev, val];\n    }\n\n    return this.set(name, value);\n  }\n\n  // alias to \"set\"\n  header(name: string | object, value?: string | string[]) {\n    return this.set(name, value);\n  }\n\n  writeHead(code: number, headers: { [name: string]: string | string[] } = this._headers) {\n    if (this.headersSent) {\n      console.warn(\"writeHead: headers were already sent.\")\n      return;\n    }\n\n    // write status\n    const reason = ReasonPhrases[StatusCodes[code]];\n    this.res.cork(() => {\n      this.res.writeStatus(`${code} ${reason}`);\n\n      // write headers\n      for (const name in headers) {\n        if(Array.isArray(headers[name])) {\n          for(const headerValue of headers[name]) {\n            this.res.writeHeader(name, headerValue?.toString());\n          }\n        } else {\n          this.res.writeHeader(name, headers[name]?.toString());\n        }\n      }\n    });\n\n    this.headersSent = true;\n  }\n\n  cookie(name: string, value: string | Record<string, unknown>, options: CookieOptions) {\n\n    const opts = merge({}, options) as CookieOptions;\n    const secret = this.req.secret || null;\n    const signed = opts.signed || false;\n\n    if (signed && !secret) {\n      throw new Error('cookieParser(\"secret\") required for signed cookies');\n    }\n\n    let val = typeof value === 'object'\n      ? 'j:' + JSON.stringify(value)\n      : String(value);\n\n    if (signed) {\n      val = 's:' + sign(val, secret);\n    }\n\n    if ('maxAge' in opts) {\n      opts.expires = new Date(Date.now() + opts.maxAge);\n      opts.maxAge /= 1000;\n    }\n\n    if (opts.path == null) {\n      opts.path = '/';\n    }\n\n    return this.append('Set-Cookie', cookie.serialize(name, String(val), opts));\n\n  }\n\n  clearCookie(name: string, options: Record<string, string | number>) {\n\n    const opts = merge({ expires: new Date(1), path: '/' }, options);\n    return this.cookie(name, '', opts);\n\n  }\n\n  // express-session [??]\n  private _implicitHeader () {\n    const code = StatusCodes.OK;\n    const reason = ReasonPhrases[StatusCodes[code]];\n    this.res.cork(() => {\n      this.res.writeStatus(`${code} ${reason}`);\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["chunk"]
}
