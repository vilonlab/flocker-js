var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/IncomingMessage.ts
import querystring from "querystring";
import EventEmitter from "events";
import { URL } from "url";
import { request } from "express";
import { Socket } from "./Socket.mjs";
var __originalUrlParsed;
var IncomingMessage = class extends EventEmitter {
  constructor(req, res, parameterNames, app) {
    var _a;
    super();
    this.req = req;
    this.res = res;
    this.parameterNames = parameterNames;
    this.app = app;
    // public query: querystring.ParsedUrlQuery;
    // private _url: string;
    // private _path: string;
    this._baseUrl = "";
    this._headers = {};
    this._readableState = { pipes: [] };
    this._readBodyMaxTime = 500;
    // @ts-ignore
    this.socket = new Socket(false, true);
    __privateAdd(this, __originalUrlParsed);
    this._headers = {};
    this.req.forEach((key, value) => {
      this._headers[key] = value;
      if (key === "referer") {
        this._headers["referrer"] = value;
      }
    });
    this.url = this.req.getUrl();
    this.method = this.req.getMethod().toUpperCase();
    this._rawquery = this.req.getQuery();
    this._remoteAddress = this.res.getRemoteAddressAsText();
    if (this._rawquery) {
      this.url += `?${this._rawquery}`;
    }
    __privateSet(this, __originalUrlParsed, new URL(`http://server${this.url}`));
    if ((_a = this.app.opts) == null ? void 0 : _a.readBodyMaxTime) {
      this._readBodyMaxTime = this.app.opts.readBodyMaxTime;
    }
  }
  get ip() {
    return Buffer.from(this._remoteAddress).toString();
  }
  set body(_body) {
    this._bodydata = _body;
  }
  get body() {
    var _a;
    return this._bodydata || ((_a = this._rawbody) == null ? void 0 : _a.toString());
  }
  get headers() {
    return this._headers;
  }
  set params(value) {
    this._params = value;
  }
  get params() {
    if (!this._params) {
      this._params = {};
      for (let i = 0; i < this.parameterNames.length; i++) {
        const paramName = this.parameterNames[i];
        this._params[paramName] = this.req.getParameter(i);
      }
    }
    return this._params;
  }
  get query() {
    if (!this._query) this._query = querystring.parse(this._rawquery);
    return this._query;
  }
  get baseUrl() {
    return this._baseUrl;
  }
  set baseUrl(baseUrl) {
    this._baseUrl = baseUrl;
  }
  get path() {
    const path = __privateGet(this, __originalUrlParsed).pathname.replace(this._baseUrl, "");
    return !path.startsWith("/") ? `/${path}` : path;
  }
  get(name) {
    return this.header(name);
  }
  header(name) {
    name = name.toLowerCase();
    return this._headers[name] || void 0;
  }
  accepts(...args) {
    return request.accepts.apply(this, arguments);
  }
  resume() {
    return this;
  }
  on(event, listener) {
    if (event === "data" && this._rawbody !== void 0) {
      setImmediate(() => {
        listener(this._rawbody);
        this.emit("end");
        this.emit("close");
      });
    } else {
      super.on(event, listener);
    }
    return this;
  }
  readBody() {
    return new Promise((resolve, reject) => {
      let body;
      const rejectionTimeout = setTimeout(() => {
        if (body) {
          this._rawbody = body;
          this.headers["content-length"] = String(body.length);
        }
        reject();
      }, this._readBodyMaxTime);
      this.res.onData((arrayBuffer, isLast) => {
        const chunk = Buffer.from(arrayBuffer);
        body = body && body.length !== 0 ? Buffer.concat([body, chunk]) : Buffer.concat([chunk]);
        if (isLast) {
          clearTimeout(rejectionTimeout);
          this._rawbody = body;
          resolve(body.length > 0);
        }
      });
    });
  }
};
__originalUrlParsed = new WeakMap();
export {
  IncomingMessage
};
