var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Application_exports = {};
__export(Application_exports, {
  Application: () => Application
});
module.exports = __toCommonJS(Application_exports);
var import_uWebSockets = __toESM(require("uWebSockets.js"));
var import_events = __toESM(require("events"));
var import_express = __toESM(require("express"));
var import_IncomingMessage = require("./IncomingMessage.js");
var import_ServerResponse = require("./ServerResponse.js");
function onAbort(req, res) {
  req.socket.readable = false;
  res.finished = true;
  res.aborted = true;
}
class Application extends import_events.default {
  constructor(uWSApp, opts) {
    super();
    this.uWSApp = uWSApp;
    this.opts = opts;
    // engines: {[ext: string]: EngineCallback} = {};
    // settings: {[setting: string]: any} = {};
    // cache: {[id: string]: any} = {};
    this.listeningSocket = void 0;
    this.request = import_express.default.request;
    this.response = import_express.default.response;
    uWSApp["delete"] = uWSApp["del"];
    this.init();
  }
  init() {
    import_express.application.init.apply(this, arguments);
    this.uWSApp.any("/*", async (uwsResponse, uwsRequest) => {
      const url = uwsRequest.getUrl();
      const req = new import_IncomingMessage.IncomingMessage(uwsRequest, uwsResponse, [], this);
      const res = new import_ServerResponse.ServerResponse(uwsResponse, req, this);
      uwsResponse.onAborted(onAbort.bind(void 0, req, res));
      if (req.headers["content-length"]) {
        try {
          await req["readBody"]();
        } catch (e) {
          console.warn("uWebSockets-express: failed reading request body at", url);
        }
      }
      this.handle(req, res);
    });
  }
  handle(req, res, callback) {
    import_express.default.application.handle.call(this, req, res, callback);
  }
  lazyrouter() {
    if (!this._router) {
      this._router = import_express.default.Router({
        caseSensitive: this.enabled("case sensitive routing"),
        strict: this.enabled("strict routing")
      });
      this._router.use(import_express.default.query(this.get("query parser fn")));
      const app = this;
      this._router.use(function expressInit(req, res, next) {
        if (app.enabled("x-powered-by")) res.setHeader("X-Powered-By", "Express");
        req.res = res;
        res.req = req;
        req.next = next;
        res.locals = res.locals || /* @__PURE__ */ Object.create(null);
        next();
      });
    }
    return;
  }
  engine(ext, fn) {
    import_express.application.engine.apply(this, arguments);
  }
  set(setting, val) {
    return import_express.application.set.apply(this, arguments);
  }
  enable(setting) {
    return import_express.application.enable.call(this, setting);
  }
  enabled(setting) {
    return import_express.application.enabled.call(this, setting);
  }
  render(name, options, callback) {
    return import_express.application.render.apply(this, arguments);
  }
  use(pathOrHandler, ...handlersOrRouters) {
    import_express.default.application.use.apply(this, arguments);
    return this;
  }
  get(path, ...handlers) {
    return import_express.default.application.get.apply(this, arguments);
  }
  post(path, ...handlers) {
    import_express.default.application.post.apply(this, arguments);
    return this;
  }
  patch(path, ...handlers) {
    import_express.default.application.patch.apply(this, arguments);
    return this;
  }
  options(path, ...handlers) {
    import_express.default.application.options.apply(this, arguments);
    return this;
  }
  put(path, ...handlers) {
    import_express.default.application.put.apply(this, arguments);
    return this;
  }
  /**
   * @deprecated
   */
  del(path, ...handlers) {
    return this.delete.apply(this, arguments);
  }
  delete(path, ...handlers) {
    import_express.default.application.delete.apply(this, arguments);
    return this;
  }
  head(path, ...handlers) {
    import_express.default.application.head.apply(this, arguments);
    return this;
  }
  all(path, ...handlers) {
    import_express.default.application.all.apply(this, arguments);
    return this;
  }
  listen(port, cb) {
    this.uWSApp.listen(port, (listenSocket) => {
      this.listeningSocket = listenSocket;
      cb == null ? void 0 : cb();
    });
    const self = this;
    return {
      close() {
        import_uWebSockets.default.us_listen_socket_close(self.listeningSocket);
        self.listeningSocket = null;
      }
    };
  }
  defaultConfiguration() {
    import_express.application.defaultConfiguration.apply(this);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Application
});
