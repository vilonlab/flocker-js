var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ServerResponse_exports = {};
__export(ServerResponse_exports, {
  ServerResponse: () => ServerResponse
});
module.exports = __toCommonJS(ServerResponse_exports);
var import_fs = __toESM(require("fs"));
var import_mime = __toESM(require("mime"));
var import_events = __toESM(require("events"));
var import_http_status_codes = require("http-status-codes");
var import_express = require("express");
var import_http = __toESM(require("http"));
var import_utils_merge = __toESM(require("utils-merge"));
var import_cookie = __toESM(require("cookie"));
var import_cookie_signature = require("cookie-signature");
class ServerResponse extends import_events.default {
  constructor(res, req, app) {
    super();
    this.res = res;
    this.req = req;
    this.app = app;
    this._headers = {};
    this._writes = [];
    this.statusCode = 200;
    this.headersSent = false;
    this.finished = false;
    this.locals = {};
    this.writableEnded = false;
    import_http.default.OutgoingMessage.call(this);
  }
  render(view, callback) {
    import_express.response.render.apply(this, arguments);
  }
  end(chunk, encoding) {
    if (this.finished) {
      return;
    }
    let body = chunk;
    if (encoding) {
      body = Buffer.from(chunk, encoding).toString();
    }
    if (!this.writableEnded) {
      this.writeHead(this.statusCode || this.statusCode, this._headers);
      this.res.cork(() => {
        this._writes.forEach((chunk2) => this.res.write(chunk2));
        this.res.end(body);
      });
    }
    this.finished = true;
    this.emit("finish");
    return this;
  }
  get(name) {
    return this._headers[name.toLowerCase()];
  }
  hasHeader(name) {
    return this._headers[name.toLowerCase()] !== void 0;
  }
  getHeader(name) {
    this.get(name);
  }
  setHeader(name, value) {
    this.set(name, value);
  }
  removeHeader(name) {
    delete this._headers[name.toLowerCase()];
  }
  status(code) {
    this.statusCode = code;
    return this;
  }
  sendStatus(statusCode) {
    this.status(statusCode);
    return this;
  }
  vary(field) {
    let append = "";
    if (!this._headers["vary"]) {
      this._headers["vary"] = "";
      append = field;
    } else {
      append = `, ${field}`;
    }
    this._headers["vary"] += append;
  }
  sendFile(path, fn) {
    this.type(path);
    import_fs.default.readFile(path, (err, contents) => {
      if (err) return fn(err);
      this.send(contents);
    });
  }
  send(chunk) {
    switch (typeof chunk) {
      case "string":
        if (!this.get("Content-Type")) {
          this.type("html");
        }
        break;
      case "boolean":
      case "number":
      case "object":
        if (chunk === null) {
          chunk = "";
        } else if (Buffer.isBuffer(chunk)) {
          if (!this.get("Content-Type")) {
            this.type("bin");
          }
        } else {
          return this.json(chunk);
        }
        break;
    }
    return this.end(chunk);
  }
  // enqueue to write during .end()
  write(chunk) {
    this._writes.push(chunk);
    return this;
  }
  type(type) {
    this.set("Content-Type", import_mime.default.getType(type) || type);
    return this;
  }
  json(body) {
    this.type("json").end(JSON.stringify(body));
  }
  jsonp(body) {
    this.set("Content-Type", "application/javascript");
    this.end(`callback(${JSON.stringify(body)})`);
  }
  location(url) {
    return import_express.response.location.apply(this, arguments);
  }
  redirect(codeOrPath, path) {
    return import_express.response.redirect.apply(this, arguments);
  }
  format(obj) {
    return import_express.response.format.apply(this, arguments);
  }
  set(name, value) {
    if (typeof name === "string") {
      name = name.toLowerCase();
      if (name !== "content-length") {
        this._headers[name] = value;
      }
    } else {
      for (let _name in name) {
        _name = _name.toLowerCase();
        if (_name !== "content-length") {
          this._headers[_name] = name[_name];
        }
      }
    }
    return this;
  }
  append(name, val) {
    const prev = this.get(name);
    let value = val;
    if (prev) {
      value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
    }
    return this.set(name, value);
  }
  // alias to "set"
  header(name, value) {
    return this.set(name, value);
  }
  writeHead(code, headers = this._headers) {
    if (this.headersSent) {
      console.warn("writeHead: headers were already sent.");
      return;
    }
    const reason = import_http_status_codes.ReasonPhrases[import_http_status_codes.StatusCodes[code]];
    this.res.cork(() => {
      var _a;
      this.res.writeStatus(`${code} ${reason}`);
      for (const name in headers) {
        if (Array.isArray(headers[name])) {
          for (const headerValue of headers[name]) {
            this.res.writeHeader(name, headerValue == null ? void 0 : headerValue.toString());
          }
        } else {
          this.res.writeHeader(name, (_a = headers[name]) == null ? void 0 : _a.toString());
        }
      }
    });
    this.headersSent = true;
  }
  cookie(name, value, options) {
    const opts = (0, import_utils_merge.default)({}, options);
    const secret = this.req.secret || null;
    const signed = opts.signed || false;
    if (signed && !secret) {
      throw new Error('cookieParser("secret") required for signed cookies');
    }
    let val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
    if (signed) {
      val = "s:" + (0, import_cookie_signature.sign)(val, secret);
    }
    if ("maxAge" in opts) {
      opts.expires = new Date(Date.now() + opts.maxAge);
      opts.maxAge /= 1e3;
    }
    if (opts.path == null) {
      opts.path = "/";
    }
    return this.append("Set-Cookie", import_cookie.default.serialize(name, String(val), opts));
  }
  clearCookie(name, options) {
    const opts = (0, import_utils_merge.default)({ expires: /* @__PURE__ */ new Date(1), path: "/" }, options);
    return this.cookie(name, "", opts);
  }
  // express-session [??]
  _implicitHeader() {
    const code = import_http_status_codes.StatusCodes.OK;
    const reason = import_http_status_codes.ReasonPhrases[import_http_status_codes.StatusCodes[code]];
    this.res.cork(() => {
      this.res.writeStatus(`${code} ${reason}`);
    });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ServerResponse
});
