// src/ServerResponse.ts
import fs from "fs";
import mime from "mime";
import EventEmitter from "events";
import { ReasonPhrases, StatusCodes } from "http-status-codes";
import { response } from "express";
import http from "http";
import merge from "utils-merge";
import cookie from "cookie";
import { sign } from "cookie-signature";
var ServerResponse = class extends EventEmitter {
  constructor(res, req, app) {
    super();
    this.res = res;
    this.req = req;
    this.app = app;
    this._headers = {};
    this._writes = [];
    this.statusCode = 200;
    this.headersSent = false;
    this.finished = false;
    this.locals = {};
    this.writableEnded = false;
    http.OutgoingMessage.call(this);
  }
  render(view, callback) {
    response.render.apply(this, arguments);
  }
  end(chunk, encoding) {
    if (this.finished) {
      return;
    }
    let body = chunk;
    if (encoding) {
      body = Buffer.from(chunk, encoding).toString();
    }
    if (!this.writableEnded) {
      this.writeHead(this.statusCode || this.statusCode, this._headers);
      this.res.cork(() => {
        this._writes.forEach((chunk2) => this.res.write(chunk2));
        this.res.end(body);
      });
    }
    this.finished = true;
    this.emit("finish");
    return this;
  }
  get(name) {
    return this._headers[name.toLowerCase()];
  }
  hasHeader(name) {
    return this._headers[name.toLowerCase()] !== void 0;
  }
  getHeader(name) {
    this.get(name);
  }
  setHeader(name, value) {
    this.set(name, value);
  }
  removeHeader(name) {
    delete this._headers[name.toLowerCase()];
  }
  status(code) {
    this.statusCode = code;
    return this;
  }
  sendStatus(statusCode) {
    this.status(statusCode);
    return this;
  }
  vary(field) {
    let append = "";
    if (!this._headers["vary"]) {
      this._headers["vary"] = "";
      append = field;
    } else {
      append = `, ${field}`;
    }
    this._headers["vary"] += append;
  }
  sendFile(path, fn) {
    this.type(path);
    fs.readFile(path, (err, contents) => {
      if (err) return fn(err);
      this.send(contents);
    });
  }
  send(chunk) {
    switch (typeof chunk) {
      case "string":
        if (!this.get("Content-Type")) {
          this.type("html");
        }
        break;
      case "boolean":
      case "number":
      case "object":
        if (chunk === null) {
          chunk = "";
        } else if (Buffer.isBuffer(chunk)) {
          if (!this.get("Content-Type")) {
            this.type("bin");
          }
        } else {
          return this.json(chunk);
        }
        break;
    }
    return this.end(chunk);
  }
  // enqueue to write during .end()
  write(chunk) {
    this._writes.push(chunk);
    return this;
  }
  type(type) {
    this.set("Content-Type", mime.getType(type) || type);
    return this;
  }
  json(body) {
    this.type("json").end(JSON.stringify(body));
  }
  jsonp(body) {
    this.set("Content-Type", "application/javascript");
    this.end(`callback(${JSON.stringify(body)})`);
  }
  location(url) {
    return response.location.apply(this, arguments);
  }
  redirect(codeOrPath, path) {
    return response.redirect.apply(this, arguments);
  }
  format(obj) {
    return response.format.apply(this, arguments);
  }
  set(name, value) {
    if (typeof name === "string") {
      name = name.toLowerCase();
      if (name !== "content-length") {
        this._headers[name] = value;
      }
    } else {
      for (let _name in name) {
        _name = _name.toLowerCase();
        if (_name !== "content-length") {
          this._headers[_name] = name[_name];
        }
      }
    }
    return this;
  }
  append(name, val) {
    const prev = this.get(name);
    let value = val;
    if (prev) {
      value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
    }
    return this.set(name, value);
  }
  // alias to "set"
  header(name, value) {
    return this.set(name, value);
  }
  writeHead(code, headers = this._headers) {
    if (this.headersSent) {
      console.warn("writeHead: headers were already sent.");
      return;
    }
    const reason = ReasonPhrases[StatusCodes[code]];
    this.res.cork(() => {
      var _a;
      this.res.writeStatus(`${code} ${reason}`);
      for (const name in headers) {
        if (Array.isArray(headers[name])) {
          for (const headerValue of headers[name]) {
            this.res.writeHeader(name, headerValue == null ? void 0 : headerValue.toString());
          }
        } else {
          this.res.writeHeader(name, (_a = headers[name]) == null ? void 0 : _a.toString());
        }
      }
    });
    this.headersSent = true;
  }
  cookie(name, value, options) {
    const opts = merge({}, options);
    const secret = this.req.secret || null;
    const signed = opts.signed || false;
    if (signed && !secret) {
      throw new Error('cookieParser("secret") required for signed cookies');
    }
    let val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
    if (signed) {
      val = "s:" + sign(val, secret);
    }
    if ("maxAge" in opts) {
      opts.expires = new Date(Date.now() + opts.maxAge);
      opts.maxAge /= 1e3;
    }
    if (opts.path == null) {
      opts.path = "/";
    }
    return this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
  }
  clearCookie(name, options) {
    const opts = merge({ expires: /* @__PURE__ */ new Date(1), path: "/" }, options);
    return this.cookie(name, "", opts);
  }
  // express-session [??]
  _implicitHeader() {
    const code = StatusCodes.OK;
    const reason = ReasonPhrases[StatusCodes[code]];
    this.res.cork(() => {
      this.res.writeStatus(`${code} ${reason}`);
    });
  }
};
export {
  ServerResponse
};
