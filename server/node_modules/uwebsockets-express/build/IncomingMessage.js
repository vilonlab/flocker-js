var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var IncomingMessage_exports = {};
__export(IncomingMessage_exports, {
  IncomingMessage: () => IncomingMessage
});
module.exports = __toCommonJS(IncomingMessage_exports);
var import_querystring = __toESM(require("querystring"));
var import_events = __toESM(require("events"));
var import_url = require("url");
var import_express = require("express");
var import_Socket = require("./Socket.js");
var __originalUrlParsed;
class IncomingMessage extends import_events.default {
  constructor(req, res, parameterNames, app) {
    var _a;
    super();
    this.req = req;
    this.res = res;
    this.parameterNames = parameterNames;
    this.app = app;
    // public query: querystring.ParsedUrlQuery;
    // private _url: string;
    // private _path: string;
    this._baseUrl = "";
    this._headers = {};
    this._readableState = { pipes: [] };
    this._readBodyMaxTime = 500;
    // @ts-ignore
    this.socket = new import_Socket.Socket(false, true);
    __privateAdd(this, __originalUrlParsed);
    this._headers = {};
    this.req.forEach((key, value) => {
      this._headers[key] = value;
      if (key === "referer") {
        this._headers["referrer"] = value;
      }
    });
    this.url = this.req.getUrl();
    this.method = this.req.getMethod().toUpperCase();
    this._rawquery = this.req.getQuery();
    this._remoteAddress = this.res.getRemoteAddressAsText();
    if (this._rawquery) {
      this.url += `?${this._rawquery}`;
    }
    __privateSet(this, __originalUrlParsed, new import_url.URL(`http://server${this.url}`));
    if ((_a = this.app.opts) == null ? void 0 : _a.readBodyMaxTime) {
      this._readBodyMaxTime = this.app.opts.readBodyMaxTime;
    }
  }
  get ip() {
    return Buffer.from(this._remoteAddress).toString();
  }
  set body(_body) {
    this._bodydata = _body;
  }
  get body() {
    var _a;
    return this._bodydata || ((_a = this._rawbody) == null ? void 0 : _a.toString());
  }
  get headers() {
    return this._headers;
  }
  set params(value) {
    this._params = value;
  }
  get params() {
    if (!this._params) {
      this._params = {};
      for (let i = 0; i < this.parameterNames.length; i++) {
        const paramName = this.parameterNames[i];
        this._params[paramName] = this.req.getParameter(i);
      }
    }
    return this._params;
  }
  get query() {
    if (!this._query) this._query = import_querystring.default.parse(this._rawquery);
    return this._query;
  }
  get baseUrl() {
    return this._baseUrl;
  }
  set baseUrl(baseUrl) {
    this._baseUrl = baseUrl;
  }
  get path() {
    const path = __privateGet(this, __originalUrlParsed).pathname.replace(this._baseUrl, "");
    return !path.startsWith("/") ? `/${path}` : path;
  }
  get(name) {
    return this.header(name);
  }
  header(name) {
    name = name.toLowerCase();
    return this._headers[name] || void 0;
  }
  accepts(...args) {
    return import_express.request.accepts.apply(this, arguments);
  }
  resume() {
    return this;
  }
  on(event, listener) {
    if (event === "data" && this._rawbody !== void 0) {
      setImmediate(() => {
        listener(this._rawbody);
        this.emit("end");
        this.emit("close");
      });
    } else {
      super.on(event, listener);
    }
    return this;
  }
  readBody() {
    return new Promise((resolve, reject) => {
      let body;
      const rejectionTimeout = setTimeout(() => {
        if (body) {
          this._rawbody = body;
          this.headers["content-length"] = String(body.length);
        }
        reject();
      }, this._readBodyMaxTime);
      this.res.onData((arrayBuffer, isLast) => {
        const chunk = Buffer.from(arrayBuffer);
        body = body && body.length !== 0 ? Buffer.concat([body, chunk]) : Buffer.concat([chunk]);
        if (isLast) {
          clearTimeout(rejectionTimeout);
          this._rawbody = body;
          resolve(body.length > 0);
        }
      });
    });
  }
}
__originalUrlParsed = new WeakMap();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  IncomingMessage
});
