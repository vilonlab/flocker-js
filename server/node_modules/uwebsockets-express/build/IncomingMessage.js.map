{
  "version": 3,
  "sources": ["../src/IncomingMessage.ts"],
  "sourcesContent": ["import uWS from \"uWebSockets.js\";\nimport http from \"http\";\nimport querystring from \"querystring\";\nimport EventEmitter from \"events\";\nimport { URL } from \"url\";\nimport { request } from \"express\";\nimport { Socket } from \"./Socket.js\";\nimport { Application } from \"./Application.js\";\n\nexport class IncomingMessage extends EventEmitter implements http.IncomingMessage {\n  public url: string;\n  public originalUrl: string; // used by express router\n  public method: string;\n\n  // public query: querystring.ParsedUrlQuery;\n\n  // private _url: string;\n  // private _path: string;\n  private _baseUrl: string = \"\";\n  private _rawquery: string;\n  private _query: querystring.ParsedUrlQuery;\n  private _headers: http.IncomingHttpHeaders = {};\n  private _params: {[name: string]: string};\n  private _bodydata: any;\n  private _rawbody: any;\n  private _remoteAddress: ArrayBuffer;\n  private _readableState = { pipes: [] };\n  private _readBodyMaxTime = 500;\n\n  public aborted: boolean;\n\n  // @ts-ignore\n  public socket = new Socket(false, true);\n\n  #_originalUrlParsed: URL;\n\n  constructor(\n    private req: uWS.HttpRequest,\n    private res: uWS.HttpResponse,\n    private parameterNames: string[],\n    private app: Application\n  ) {\n    super();\n\n    this._headers = {};\n    this.req.forEach((key, value) => {\n      this._headers[key] = value;\n\n      // workaround: also consider 'referrer'\n      if (key === \"referer\") {\n        this._headers['referrer'] = value;\n      }\n    });\n\n    this.url = this.req.getUrl();\n    this.method = this.req.getMethod().toUpperCase();\n\n    this._rawquery = this.req.getQuery();\n    this._remoteAddress = this.res.getRemoteAddressAsText();\n\n    if (this._rawquery) {\n      this.url += `?${this._rawquery}`;\n    }\n\n    this.#_originalUrlParsed = new URL(`http://server${this.url}`);\n\n    if (this.app.opts?.readBodyMaxTime) {\n      this._readBodyMaxTime = this.app.opts.readBodyMaxTime;\n    }\n  }\n\n  get ip () {\n    return Buffer.from(this._remoteAddress).toString();\n  }\n\n  set body (_body: any) {\n    this._bodydata = _body;\n  }\n\n  get body () {\n    return this._bodydata || this._rawbody?.toString();\n  }\n\n  get headers (): http.IncomingHttpHeaders {\n    return this._headers;\n  }\n\n  set params (value) {\n    this._params = value;\n  }\n\n  get params(): { [name: string]: string } {\n    if (!this._params) {\n      this._params = {};\n      for (let i = 0; i < this.parameterNames.length; i++) {\n        const paramName = this.parameterNames[i];\n        this._params[paramName] = this.req.getParameter(i);\n      }\n    }\n\n    return this._params;\n  }\n\n  get query (): querystring.ParsedUrlQuery {\n    if(!this._query) this._query = querystring.parse(this._rawquery);\n    return this._query;\n  }\n\n  get baseUrl() {\n    return this._baseUrl;\n  }\n\n  set baseUrl(baseUrl) {\n    this._baseUrl = baseUrl;\n  }\n\n  get path(): string {\n    const path = this.#_originalUrlParsed.pathname.replace(this._baseUrl, \"\");\n    return (!path.startsWith(\"/\"))\n      ? `/${path}`\n      : path;\n  }\n\n  get(name: string) {\n    return this.header(name);\n  }\n\n  header(name: string) {\n    name = name.toLowerCase();\n    return this._headers[name] || undefined;\n  }\n\n  accepts(...args: any[]): string | false {\n    return request.accepts.apply(this, arguments);\n  }\n\n  resume() { return this; }\n\n  on(event: string | symbol, listener: (...args: any[]) => void) {\n    if (event === 'data' && this._rawbody !== undefined) {\n      /**\n       * req.body is synchronously before any middleware runs.\n       * here we're mimicking to trigger 'data' + 'end' + 'close' right at the moment the event is registered.\n       */\n      setImmediate(() => {\n        listener(this._rawbody);\n        this.emit('end');\n        this.emit('close');\n      });\n    } else {\n      super.on(event, listener);\n    }\n    return this;\n  }\n\n  protected readBody () {\n    return new Promise<boolean>((resolve, reject) => {\n      let body: Buffer;\n\n      //\n      // ensure request is not halted when an invalid content-length is sent by the client\n      // https://github.com/endel/uWebSockets-express/issues/9\n      //\n      const rejectionTimeout = setTimeout(() => {\n        if (body) {\n          this._rawbody = body;\n          this.headers['content-length'] = String(body.length);\n        }\n        reject();\n      }, this._readBodyMaxTime);\n\n      this.res.onData((arrayBuffer, isLast) => {\n        const chunk = Buffer.from(arrayBuffer);\n        body = (body && body.length !== 0) ? Buffer.concat([body, chunk]) : Buffer.concat([chunk]);\n\n        if (isLast) {\n          clearTimeout(rejectionTimeout);\n          this._rawbody = body;\n          resolve(body.length > 0);\n        }\n      });\n    })\n  }\n\n}\n"],
  "mappings": "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",
  "names": ["EventEmitter", "querystring"]
}
